{
    "collab_server" : "",
    "contents" : "####################################################################################\n####\t\tDefining class containing data, model and options\t\t####\n####################################################################################\n\n#' @include aaa_generics.R\nNULL\n\n#' Class \"SaemixObject\"\n#' \n#' An object of the SaemixObject class, storing the input to saemix, and the results obtained by a call\n#' to the SAEM algorithm\n#' \n#' Details of the algorithm can be found in the pdf file accompanying the package.\n#' \n#' @name SaemixObject-class\n#' @docType class\n#' @aliases SaemixObject-class SaemixObject [<-,SaemixObject-method\n#' print,SaemixObject predict,SaemixObject showall,SaemixObject show,SaemixObject summary,SaemixObject\n#' @section Objects from the Class:\n#' An object of the SaemixObject class is created after a call to \\code{\\link{saemix}} and contain the following slots:\n#'   \\describe{\n#'     \\item{\\code{data}:}{Object of class \\code{\"SaemixData\"}: saemix dataset, created by a call to \\code{saemixData}}\n#'     \\item{\\code{model}:}{Object of class \\code{\"SaemixModel\"}: saemix model, created by a call to \\code{saemixModel}}\n#'     \\item{\\code{results}:}{Object of class \\code{\"SaemixData\"}: saemix dataset, created by a call to \\code{saemixData}}\n#'     \\item{\\code{rep.data}:}{Object of class \\code{\"SaemixRepData\"}: (internal) replicated saemix dataset, used the execution of the algorithm}\n#'     \\item{\\code{sim.data}:}{Object of class \\code{\"SaemixSimData\"}: simulated saemix dataset}\n#'     \\item{\\code{options}:}{Object of class \\code{\"list\"}: list of settings for the algorithm}\n#'     \\item{\\code{prefs}:}{Object of class \\code{\"list\"}: list of graphical options for the graphs}\n#'   }\n#' @section Methods:\n#'   \\describe{\n#'     \\item{[<-}{\\code{signature(x = \"SaemixObject\")}: replace elements of object}\n#'     \\item{[}{\\code{signature(x = \"SaemixObject\")}: access elements of object}\n#'     \\item{initialize}{\\code{signature(.Object = \"SaemixObject\")}: internal function to initialise object, not to be used}\n#'     \\item{plot}{\\code{signature(x = \"SaemixObject\")}: plot the data}\n#'     \\item{print}{\\code{signature(x = \"SaemixObject\")}: prints details about the object (more extensive than show)}\n#'     \\item{showall}{\\code{signature(object = \"SaemixObject\")}: shows all the elements in the object}\n#'     \\item{show}{\\code{signature(object = \"SaemixObject\")}: prints details about the object}\n#'     \\item{summary}{\\code{signature(object = \"SaemixObject\")}: summary of the object. Returns a list with a number of elements extracted from the object.}\n#' \t }\n#' @references Kuhn E, Lavielle M. Maximum likelihood estimation in nonlinear  mixed effects models. Computational Statistics and Data Analysis 49, 4 (2005), 1020-1038.\n#' \n#' Comets E, Lavenu A, Lavielle M. SAEMIX, an R version of the SAEM algorithm. 20th meeting of the \n#' Population Approach Group in Europe, Athens, Greece (2011), Abstr 2173.\n#' @author Emmanuelle Comets \\email{emmanuelle.comets@@inserm.fr}\n#' @author Audrey Lavenu\n#' @author Marc Lavielle.\n#' @seealso \\code{\\link{SaemixData}} \\code{\\link{SaemixModel}} \\code{\\link{saemixControl}} \\code{\\link{saemix}}\n#' \\code{\\link{plot.saemix}},\n#' @keywords classes\n#' @include SaemixData.R\n#' @include SaemixModel.R\n#' @include SaemixRes.R\n#' @exportClass SaemixObject\n#' @examples\n#' \n#' showClass(\"SaemixObject\")\n#' \n\n###############################\n# definition\nsetClass(Class=\"SaemixObject\",\n  representation=representation(\n    data=\"SaemixData\",\t\t# Data\n    model=\"SaemixModel\",\t# Model\n    results=\"SaemixRes\",\t# Fit results\n    rep.data=\"SaemixRepData\",\t# Data replicates during algorithm (nb chains)\n    sim.data=\"SaemixSimData\", \t# Simulated data\n    options=\"list\",\t\t# Options and parameters for algorithm\n    prefs=\"list\"\t\t# Options for graphs\n  ),\n  validity=function(object){\n#    cat (\"--- Checking SaemixObject object ---\\n\")\n    validObject(object@data)\n    validObject(object@model)\n    return(TRUE)\n  }\n)\n\n###############################\n# Initialize\n#' @rdname initialize-methods\n#' @exportMethod initialize\n\nsetMethod(\n  f=\"initialize\",\n  signature=\"SaemixObject\",\n  definition= function (.Object,data,model,options=list()){\n#    cat (\"--- initialising SaemixObject --- \\n\")\n    if(model[\"error.model\"]=='exponential') {\n      yobs<-data[\"data\"][,data[\"name.response\"]]\n      y<-log(cutoff(yobs))\n      data[\"yorig\"]<-yobs\n      data[\"data\"][,data[\"name.response\"]]<-y\n    }\n    .Object@data<-data\n# Adjusting number of covariates\n    if(dim(model@covariate.model)[1]>length(data@name.covariates)) {\n      cat(\"The number of covariates in model (\",dim(model@covariate.model)[1],\") is larger than the number of covariates in the dataset (\",length(data@name.covariates),\"), keeping only the first\",length(data@name.covariates),\":\",data@name.covariates,\".\\n\")\n      model@covariate.model<-model@covariate.model[1:length(data@name.covariates),]\n    }\n    if(dim(model@covariate.model)[1]<length(data@name.covariates) & dim(model@covariate.model)[1]>0) {\n    \tcat(\"The number of covariates in model (\",dim(model@covariate.model)[1],\") is smaller than the number of covariates in the dataset (\",length(data@name.covariates),\"), assuming no covariate-parameter relationship for the remaining covariates; please check covariates:\",data@name.covariates,\".\\n\")\n    \tl1<-rep(0,dim(model@covariate.model)[2])\n    \tn1<-length(data@name.covariates)-dim(model@covariate.model)[1]\n    \tmodel@covariate.model<-rbind(model@covariate.model, matrix(rep(l1,n1),nrow=n1))\n    }\n# setting the names of the fixed effects\n    if(dim(model@covariate.model)[1]>0) {\n      nam.with.cov<-rep(\"\",length(model@covariate.model))\n      row1<-matrix(rep(model@name.modpar,length(data@name.covariates)), ncol=length(model@name.modpar),byrow=TRUE)\n      col1<-matrix(rep(data@name.covariates,length(model@name.modpar)), ncol=length(model@name.modpar))\n      idcov<-which(model@covariate.model==1)\n      nam.with.cov[idcov]<-paste(\"beta_\",col1[idcov],\"(\",row1[idcov],\")\",sep=\"\")\n      nam1<-rbind(model@name.modpar,matrix(nam.with.cov, ncol=length(model@name.modpar)))\n      nam1<-c(nam1)\n      model@name.fixed<-nam1[nam1!=\"\"]\n    } else model@name.fixed<-model@name.modpar\n    i1.omega2<-model@indx.omega\n    model@name.random<-paste(\"omega2\",model@name.modpar[model@indx.omega], sep=\".\")\n    .Object@model<-model\n    .Object@model@betaest.model<-matrix(c(rep(1,.Object@model@nb.parameters), c(t(.Object@model@covariate.model))),ncol=.Object@model@nb.parameters,byrow=TRUE)\n    \n# Covariates\n    .Object@model@name.cov<-.Object@data@name.covariates\n    if(length(.Object@model@name.cov)>0 & sum(.Object@model@covariate.model)>0) {\n      try(rownames(.Object@model@covariate.model)<-.Object@model@name.cov)\n      try(rownames(.Object@model@betaest.model)[2:(1+ length(.Object@model@name.cov))]<-.Object@model@name.cov)\n    }\n    ucov <- rownames(.Object@model@covariate.model)[ rowSums(.Object@model@covariate.model)>0]\n    if(length(ucov)>0) {\n      for(icov in ucov) {\n      \txdat<-subset(.Object@data@data,is.na(get(icov)))\n      \tif(dim(xdat)[1]>0) {\n      \t\timis<-unique(xdat[,.Object@data@name.group])\n      \t\tcat(\"Missing values for covariate\",as.character(icov),\"for which a parameter-covariate relationship is estimated: removing subject(s)\",imis,\"from the dataset.\\n\")\n      \t}\n      \t.Object@data<-subset(.Object@data,!is.na(get(icov)))\n      }\n    }\n# Initialising options\n    opt<-saemixControl()\n    if(length(options)>0) {\n    for(i in names(options)) opt[i]<-options[i]\n      if(!opt$fix.seed) {\n      rm(.Random.seed)\n      runif(1)\n      opt$seed<-.Random.seed[5]\n      }\n    if(is.null(options$nb.chains) & data@N>0) opt$nb.chains<-ceiling(50/data@N)\n    if(data@N>0 && data@N<50 & opt$nb.chains<ceiling(50/data@N)) {\n      cat(\"The number of subjects is small, increasing the number of chains to\", ceiling(50/data@N),\"to improve convergence\\n\")\n      opt$nb.chains<-ceiling(50/data@N)\n    }\n    if(opt$ipar.lmcmc<2) {\n      opt$ipar.lmcmc<-2\n      cat(\"Value of L_MCMC too small, setting it to 2 (computation of the conditional means and variances of the individual parameters)\\n\")\n    }\n    }\n    \n    if(length(opt$nbiter.sa)==1){\n      opt$nbiter.sa<-max(1,opt$nbiter.sa)\n    } else{\n      opt$nbiter.sa<-round(opt$nbiter.saemix[1]/2)\n    }\n\n    opt$nbiter.tot<-sum(opt$nbiter.saemix)\n    .Object@options<-opt\n# Options for plots\n    .Object@prefs<-saemix.plot.setoptions(.Object)\n# Object validation\n    validObject(.Object)\n    return (.Object )\n  }\n)\n\n###########################\tDefault options\t\t#############################\n\n#' List of options for running the algorithm SAEM\n#' \n#' List containing the variables relative to the optimisation algorithm. All\n#' these elements are optional and will be set to default values when running\n#' the algorithm if they are not specified by the user.\n#' \n#' All the variables are optional and will be set to their default value when\n#' running \\code{\\link{saemix}}.\n#' \n#' The function \\code{\\link{saemix}} returns an object with an element options\n#' containing the options used for the algorithm, with defaults set for\n#' elements which have not been specified by the user.\n#' \n#' These elements are used in subsequent functions and are not meant to be used\n#' directly.\n#' \n#' @param map a boolean specifying whether to estimate the individual parameters (MAP estimates). Defaults to TRUE\n#' @param fim a boolean specifying whether to estimate the Fisher Information Matrix and derive the estimation errors \n#' for the parameters. Defaults to TRUE. The linearised approximation to the log-likelihood is also computed in the process\n#' @param ll.is a boolean specifying whether to estimate the log-likelihood by importance sampling. Defaults to TRUE\n#' @param ll.gq a boolean specifying whether to estimate the log-likelihood by Gaussian quadrature. Defaults to FALSE\n#' @param nbiter.saemix nb of iterations in each step (a vector containing 2\n#' elements)\n#' @param nb.chains nb of chains to be run in parallel in the MCMC algorithm.\n#' Defaults to 1.\n#' @param nbiter.burn nb of iterations for burning\n#' @param nbiter.mcmc nb of iterations in each kernel during the MCMC step\n#' @param proba.mcmc probability of acceptance\n#' @param stepsize.rw stepsize for kernels q2 and q3. Defaults to 0.4\n#' @param rw.init initial variance parameters for kernels. Defaults to 0.5\n#' @param alpha.sa parameter controlling cooling in the Simulated Annealing\n#' algorithm. Defaults to 0.97\n#' @param fix.seed TRUE (default) to use a fixed seed for the random number\n#' generator. When FALSE, the random number generator is initialised using a\n#' new seed, created from the current time.  Hence, different sessions started\n#' at (sufficiently) different times will give different simulation results.\n#' The seed is stored in the element seed of the options list.\n#' @param seed seed for the random number generator. Defaults to 123456\n#' @param nmc.is nb of samples used when computing the likelihood through\n#' importance sampling\n#' @param nu.is number of degrees of freedom of the Student distribution used\n#' for the estimation of the log-likelihood by Importance Sampling. Defaults to\n#' 4\n#' @param print.is when TRUE, a plot of the likelihood as a function of the\n#' number of MCMC samples when computing the likelihood through importance\n#' sampling is produced and updated every 500 samples. Defaults to FALSE\n#' @param nbdisplay nb of iterations after which to display progress\n#' @param displayProgress when TRUE, the convergence plots are plotted after\n#' every nbdisplay iteration, and a dot is written in the terminal window to\n#' indicate progress. When FALSE, plots are not shown and the algorithm runs\n#' silently. Defaults to TRUE\n#' @param nnodes.gq number of nodes to use for the Gaussian quadrature when\n#' computing the likelihood with this method (defaults to 12)\n#' @param nsd.gq span (in SD) over which to integrate when computing the\n#' likelihood by Gaussian quadrature. Defaults to 4 (eg 4 times the SD)\n#' @param maxim.maxiter Maximum number of iterations to use when maximising the\n#' fixed effects in the algorithm. Defaults to 100\n#' @param nb.sim number of simulations to perform to produce the VPC plots or\n#' compute npde. Defaults to 1000\n#' @param nb.simpred number of simulations used to compute mean predictions\n#' (ypred element), taken as a random sample within the nb.sim simulations used\n#' for npde\n#' @param ipar.lmcmc number of iterations required to assume convergence for\n#' the conditional estimates. Defaults to 50\n#' @param ipar.rmcmc confidence interval for the conditional mean and variance.\n#' Defaults to 0.95\n#' @param print whether the results of the fit should be printed out. Defaults\n#' to TRUE\n#' @param save whether the results of the fit should be saved to a file.\n#' Defaults to TRUE\n#' @param save.graphs whether diagnostic graphs and individual graphs should be\n#' saved to files. Defaults to TRUE\n#' @param directory the directory in which to save the results. Defaults to\n#' \"newdir\" in the current directory\n#' @param warnings whether warnings should be output during the fit. Defaults\n#' to FALSE\n#' @author Emmanuelle Comets <emmanuelle.comets@@inserm.fr>, Audrey Lavenu,\n#' Marc Lavielle.\n#' @seealso \\code{\\link{SaemixData}},\\code{\\link{SaemixModel}},\n#' \\code{\\link{SaemixObject}}, \\code{\\link{saemix}}\n#' @references Kuhn E, Lavielle M. Maximum likelihood estimation in nonlinear\n#' mixed effects models. Computational Statistics and Data Analysis 49, 4\n#' (2005), 1020-1038.\n#' \n#' Comets E, Lavenu A, Lavielle M. SAEMIX, an R version of the SAEM algorithm.\n#' 20th meeting of the Population Approach Group in Europe, Athens, Greece\n#' (2011), Abstr 2173.\n#' @keywords models\n#' @examples\n#' \n#' \n#' # All default options\n#' saemix.options<-saemixControl()\n#' \n#' # All default options, changing seed\n#' saemix.options<-saemixControl(seed=632545)\n#' \n#' \n#' @export saemixControl\n\nsaemixControl<-function(map=TRUE,fim=TRUE,ll.is=TRUE,ll.gq=FALSE,nbiter.saemix=c(300,100), nb.chains=1,fix.seed=TRUE,seed=23456,nmc.is=5000,nu.is=4, print.is=FALSE,nbdisplay=100,displayProgress=TRUE,nbiter.burn=5, nbiter.mcmc=c(2,2,2),proba.mcmc=0.4,stepsize.rw=0.4,rw.init=0.5,alpha.sa=0.97,  nnodes.gq=12,nsd.gq=4,maxim.maxiter=100,nb.sim=1000,nb.simpred=100, ipar.lmcmc=50,ipar.rmcmc=0.05, print=TRUE, save=TRUE, save.graphs=TRUE,directory=\"newdir\",warnings=FALSE) {\n  if(fix.seed) seed<-seed else {\n    rm(.Random.seed)\n    runif(1)\n    seed<-.Random.seed[5]\n  }\n  if(ipar.lmcmc<2) {\n    ipar.lmcmc<-2\n    cat(\"Value of L_MCMC too small, setting it to 2 (computation of the conditional means and variances of the individual parameters)\\n\")\n  }\n  list(map=map,fim=fim,ll.is=ll.is,ll.gq=ll.gq,nbiter.saemix=nbiter.saemix, nbiter.burn=nbiter.burn,nb.chains=nb.chains,fix.seed=fix.seed,seed=seed, nmc.is=nmc.is,nu.is=nu.is,print.is=print.is, nbdisplay=nbdisplay,displayProgress=displayProgress,print=print,save=save, save.graphs=save.graphs,directory=directory,warnings=warnings, nbiter.mcmc=nbiter.mcmc,proba.mcmc=proba.mcmc,stepsize.rw=stepsize.rw, rw.init=rw.init,alpha.sa=alpha.sa,nnodes.gq=nnodes.gq,nsd.gq=nsd.gq, maxim.maxiter=maxim.maxiter,nb.sim=nb.sim,nb.simpred=nb.simpred,\nipar.lmcmc=ipar.lmcmc,ipar.rmcmc=ipar.rmcmc)\n}\n\n####################################################################################\n####\t\t\tsaemixObject class - accesseur\t\t\t\t####\n####################################################################################\n\n##' Get/set methods for SaemixObject object\n##' \n##' Access slots of a SaemixObject object using the object[\"slot\"] format\n##' \n#' @param x object\n#' @param i element to be replaced\n#' @param j element to replace with\n#' @param drop whether to drop unused dimensions\n#' @keywords methods\n#' @exportMethod [\n#' @exportMethod [<-\n##### @name [\n##### @aliases [,SaemixObject-method\n##### @docType methods\n##### @rdname extract-methods\n\n# Getteur\nsetMethod(\n  f =\"[\",\n  signature = \"SaemixObject\" ,\n  definition = function (x,i,j,drop ){\n  switch (EXPR=i,\n    \"data\"={return(x@data)},\n    \"model\"={return(x@model)},\n    \"results\"={return(x@results)},\n    \"rep.data\"={return(x@rep.data)},\n    \"sim.data\"={return(x@sim.data)},\n    \"options\"={return(x@options)},\n    \"prefs\"={return(x@prefs)},\n    stop(\"No such attribute\\n\")\n   )\n  }\n)\n\n# Setteur\nsetReplaceMethod(\n  f =\"[\",\n  signature = \"SaemixObject\" ,\n  definition = function (x,i,j,value){\n  switch (EXPR=i,\n    \"data\"={x@data<-value},\n    \"model\"={x@model<-value},\n    \"results\"={x@results<-value},\n    \"rep.data\"={x@rep.data<-value},\n    \"sim.data\"={x@sim.data<-value},\n    \"options\"={x@options<-value},\n    \"prefs\"={x@prefs<-value},\n    stop(\"No such attribute\\n\")\n   )\n   validObject(x)\n   return(x)\n  }\n)\n\n\n####################################################################################\n####\t\t\t\tSummary method for SaemixObject\t\t\t####\n####################################################################################\n#' @exportMethod summary\n\nsetMethod(\"summary\",\"SaemixObject\",\n  function(object, print=TRUE, ...) {\n    if(length(object@results@fixed.effects)==0) {\n      cat(\"Object of class SaemixObject, no fit performed yet.\\n\")\n      return()\n    }\n    digits<-2;nsmall<-2\n    if(print) {\n    cat(\"----------------------------------------------------\\n\")\n    cat(\"-----------------  Fixed effects  ------------------\\n\")\n    cat(\"----------------------------------------------------\\n\")\n    }\n    if(length(object@results@se.fixed)==0) {\n      tab<-data.frame(c(object@results@name.fixed, object@results@name.res[object@results@indx.res]), c(object@results@fixed.effects,object@results@respar[object@results@indx.res]))\n      colnames(tab)<-c(\"Parameter\",\"Estimate\")\n    } else {\n      tab<-data.frame(c(object@results@name.fixed, object@results@name.res[object@results@indx.res]), c(object@results@fixed.effects,object@results@respar[object@results@indx.res]),c(object@results@se.fixed,object@results@se.respar[object@results@indx.res]), stringsAsFactors=FALSE)\n      tab<-cbind(tab,100*abs(as.double(tab[,3])/as.double(tab[,2])))\n      colnames(tab)<-c(\"Parameter\",\"Estimate\",\"SE\",\"CV(%)\")\n      if(length(object@results@indx.cov)>0) {\n      wstat<-as.double(tab[,2])/as.double(tab[,3])\n      pval<-rep(\"-\",length(wstat))\n      pval[object@results@indx.cov]<-1-normcdf(abs(wstat[object@results@indx.cov]))\n      tab<-cbind(tab,\"p-value\"=pval,stringsAsFactors=FALSE)\n      }\n    }\n    tab.fix<-tab\n    for(i in 2:dim(tab)[2]) {\n     xcol<-as.double(as.character(tab[,i]))\n     idx<-which(!is.na(xcol) & xcol!=\"-\")\n     tab[idx,i]<-format(xcol[idx],digits=digits,nsmall=nsmall)\n    }\n    if(print) {\n    print(tab,quote=FALSE)\n    cat(\"----------------------------------------------------\\n\")\n    cat(\"-----------  Variance of random effects  -----------\\n\")\n    cat(\"----------------------------------------------------\\n\")\n#  cat(\"   ECO TODO: check if Omega or Omega2 (SD or variances) and can we choose ?\\n\")\n    }\n    if(length(object@results@se.omega)==0) {\n      tab<-data.frame(object@results@name.random, diag(object@results@omega)[object@results@indx.omega])\n      colnames(tab)<-c(\"Parameter\",\"Estimate\")\n    } else {\n      tab<-data.frame(object@results@name.random, diag(object@results@omega)[object@results@indx.omega], object@results@se.omega[object@results@indx.omega])\n      tab<-cbind(tab,100*as.double(tab[,3])/as.double(tab[,2]))\n      colnames(tab)<-c(\"Parameter\",\"Estimate\",\"SE\",\"CV(%)\")\n    }\n    tab.random<-tab\n    for(i in 2:dim(tab)[2]) \n      tab[,i]<-format(as.double(as.character(tab[,i])),digits=digits,nsmall=nsmall)\n    if(print) {\n    print(tab,quote=FALSE)\n    cat(\"----------------------------------------------------\\n\")\n    cat(\"------  Correlation matrix of random effects  ------\\n\")\n    cat(\"----------------------------------------------------\\n\")\n    }\n    tab<-cov2cor(object@results@omega[object@results@indx.omega, object@results@indx.omega,drop=FALSE])\n    tab.corr<-tab\n    for(i in 1:dim(tab)[2])\n      tab[,i]<-format(as.double(as.character(tab[,i])),digits=digits,nsmall=nsmall)\n    try(colnames(tab)<-rownames(tab)<-object@results@name.random)\n    if(print) print(tab,quote=FALSE)\n    l1<-rep(NA,3)\n    tab.ll<-data.frame(Method=c(\"Linearisation\",\"Importance Sampling\",\"Gaussian Quadrature\"),\"-2xLL\"=l1,AIC=l1,BIC=l1)\n    if(length(object@results@ll.lin)>0 | length(object@results@ll.is)>0 | length(object@results@ll.gq)>0) {\n    \tif(print) {\n    cat(\"----------------------------------------------------\\n\")\n    cat(\"---------------  Statistical criteria  -------------\\n\")\n    cat(\"----------------------------------------------------\\n\")\n    \t}\n    if(length(object@results@ll.lin)>0) {\n    \tif(print) {\n    cat(\"Likelihood computed by linearisation\\n\")\n    cat(\"      -2LL=\",(-2*object@results@ll.lin),\"\\n\")\n    cat(\"      AIC =\",object@results@aic.lin,\"\\n\")\n    cat(\"      BIC =\",object@results@bic.lin,\"\\n\")\n    \t}\n    tab.ll[1,2:4]<-c((-2*object@results@ll.lin),object@results@aic.lin, object@results@bic.lin)\n    }\n    if(length(object@results@ll.is)>0) {\n    \tif(print) {\n    cat(\"\\nLikelihood computed by importance sampling\\n\")\n    cat(\"      -2LL=\",(-2*object@results@ll.is),\"\\n\")\n    cat(\"      AIC =\",object@results@aic.is,\"\\n\")\n    cat(\"      BIC =\",object@results@bic.is,\"\\n\")\n    \t}\n    tab.ll[2,2:4]<-c((-2*object@results@ll.is),object@results@aic.is, object@results@bic.is)\n    }  \n    if(length(object@results@ll.gq)>0) {\n    \tif(print) {\n    cat(\"\\nLikelihood computed by Gaussian quadrature\\n\")\n    cat(\"      -2LL=\",(-2*object@results@ll.gq),\"\\n\")\n    cat(\"      AIC =\",object@results@aic.gq,\"\\n\")\n    cat(\"      BIC =\",object@results@bic.gq,\"\\n\")\n    \t}\n    tab.ll[3,2:4]<-c((-2*object@results@ll.gq),object@results@aic.gq, object@results@bic.gq)\n    }\n    if(print) cat(\"----------------------------------------------------\\n\")\n    }\n    tab<-data.frame(Id=unique(object@data@data[,object@data@name.group]), object@results@cond.mean.psi)\n    try(colnames(tab)[-c(1)]<-object@model@name.modpar,silent=TRUE)\n    npar<-length(object@results@name.fixed)\n    coef<-list(fixed=tab.fix[1:npar,2],random=list(map.psi=object@results@map.psi, cond.mean.psi=tab))\n    sigma<-tab.fix[-c(1:npar),2]\n\n    res<-list(fixed.effects=tab.fix,sigma=sigma,random.effects=tab.random, correlation.matrix=tab.corr,logLik=tab.ll,coefficients=coef)\n    if(length(object@results@fim)>0) res$FIM<-object@results@fim\n    res$data<-list(N=object@data@N,nobs=list(ntot=object@data@ntot.obs, nind=object@data@nind.obs),data=object@data@data)\n    if(length(object@results@ypred)>0 | length(object@results@ipred)>0  | length(object@results@ppred)>0 | length(object@results@icpred)>0) {\n      res$fitted<-list(population=list(pop.param=object@results@ppred, pop.mean=object@results@ypred),individual=list(map.ipred=object@results@ipred, cond.ipred=object@results@icpred))\n    }\n     if(length(object@results@wres)>0 | length(object@results@iwres)>0  | length(object@results@icwres)>0 | length(object@results@pd)>0) {\n      res$residuals<-list(population=list(wres=object@results@wres), individual=list(map.iwres=object@results@iwres,cond.iwres=object@results@icwres, pd=object@results@pd, npde=object@results@npde))\n    }\n   \n    invisible(res)\n }\n)\n\n####################################################################################\n####\t\t\tPrint and show methods for SaemixObject\t\t\t####\n####################################################################################\n\n#' @exportMethod print\n\nsetMethod(\"print\",\"SaemixObject\",\n  function(x,nlines=10,...) {\n    cat(\"Nonlinear mixed-effects model fit by the SAEM algorithm\\n\")\n    cat(\"-----------------------------------\\n\")\n    cat(\"----          Data             ----\\n\")\n    cat(\"-----------------------------------\\n\")\n    print(x@data,nlines=nlines)\n    cat(\"-----------------------------------\\n\")\n    cat(\"----          Model            ----\\n\")\n    cat(\"-----------------------------------\\n\")\n    print(x@model)\n    cat(\"-----------------------------------\\n\")\n    cat(\"----    Key algorithm options  ----\\n\")\n    cat(\"-----------------------------------\\n\")\n    if(x@options$map) cat(\"    Estimation of individual parameters (MAP)\\n\")\n    if(x@options$fim) cat(\"    Estimation of standard errors and linearised log-likelihood\\n\")\n    if(x@options$ll.is) cat(\"    Estimation of log-likelihood by importance sampling\\n\")\n    if(x@options$ll.gq) cat(\"    Estimation of log-likelihood by gaussian quadrature\\n\")\n    if(as.integer(x@options$map+x@options$fim+x@options$ll.is+x@options$ll.gq)==0) cat(\"    Algorithms: estimation only\\n\")\n    st1<-paste(c(\"K1=\",\"K2=\"),x@options$nbiter.saemix,sep=\"\",collapse=\", \")\n    cat(\"    Number of iterations: \",st1,\"\\n\")\n    cat(\"    Number of chains: \",x@options$nb.chains,\"\\n\")\n    cat(\"    Seed: \",x@options$seed,\"\\n\")\n    if(x@options$ll.is) cat(\"    Number of MCMC iterations for IS: \",x@options$nmc.is,\"\\n\")\n    cat(\"    Simulations:\\n\")\n    cat(\"        nb of simulated datasets used for npde: \",x@options$nb.sim,\"\\n\")\n    cat(\"        nb of simulated datasets used for VPC: \",x@options$nb.simpred,\"\\n\")\n    cat(\"    Input/output\\n\")\n    cat(\"        save the results to a file: \",x@options$save,\"\\n\")\n    cat(\"        save the graphs to files: \",x@options$save.graphs,\"\\n\")\n    if(x@options$save | x@options$save.graphs) cat(\"        directory where results should be saved: \",x@options$directory,\"\\n\")\n    cat(\"----------------------------------------------------\\n\")\n    cat(\"----                  Results                   ----\\n\")\n    print(x@results)\n  }\n)\n\n#' @exportMethod show\n\nsetMethod(\"show\",\"SaemixObject\",\n  function(object) {\n#    cat(\"Object of class SaemixObject\\n\")\n    cat(\"Nonlinear mixed-effects model fit by the SAEM algorithm\\n\")\n    cat(\"-----------------------------------------\\n\")\n    cat(\"----         Data and Model          ----\\n\")\n    cat(\"-----------------------------------------\\n\")\n#    show(object@data)\n    cat(\"Data\\n\")\n    cat(\"    Dataset\",object@data@name.data,\"\\n\")\n    st1<-paste(object@data@name.response,\" ~ \",paste(object@data@name.predictors, collapse=\" + \"),\" | \", object@data@name.group,sep=\"\")\n    cat(\"    Longitudinal data:\",st1,\"\\n\\n\")\n#    show(object@model)\n    cat(\"Model:\\n\")\n    if(length(object@model@description)>0 && nchar(object@model@description)>0) {\n      cat(\"   \",object@model@description,\"\\n\")}\n    fix1<-ifelse(object@model@fixed.estim==1,\"\",\" [fixed]\")\n    cat(\"    \",object@model@nb.parameters,\"parameters:\", paste(object@model@name.modpar,fix1,sep=\"\"),\"\\n\")\n    cat(\"     error model:\",object@model@error.model,\"\\n\")\n    if(dim(object@model@covariate.model)[1]>0) {\n      cat(\"     covariate model:\\n\")\n      print(object@model@covariate.model) \n    } else cat(\"     No covariate\\n\")\n    cat(\"\\n\")\n    cat(\"Key options\\n\")\n    if(object@options$map) cat(\"    Estimation of individual parameters (MAP)\\n\")\n    if(object@options$fim) cat(\"    Estimation of standard errors and linearised log-likelihood\\n\")\n    if(object@options$ll.is) cat(\"    Estimation of log-likelihood by importance sampling\\n\")\n    if(object@options$ll.gq) cat(\"    Estimation of log-likelihood by gaussian quadrature\\n\")\n    if(as.integer(object@options$map+object@options$fim+object@options$ll.is+object@options$ll.gq)==0) cat(\"    Algorithms: estimation only\\n\")\n    st1<-paste(c(\"K1=\",\"K2=\"),object@options$nbiter.saemix,sep=\"\",collapse=\", \")\n    cat(\"    Number of iterations: \",st1,\"\\n\")\n    cat(\"    Number of chains: \",object@options$nb.chains,\"\\n\")\n    cat(\"    Seed: \",object@options$seed,\"\\n\")\n    if(object@options$ll.is) cat(\"    Number of MCMC iterations for IS: \",object@options$nmc.is,\"\\n\")\n    cat(\"    Input/output\\n\")\n    if(object@options$save)\n      cat(\"        save the results to a file: \",object@options$save,\"\\n\") else \n      cat(\"        results not saved\\n\")\n    if(object@options$save.graphs)\n      cat(\"        save the graphs to files: \",object@options$save.graphs,\"\\n\") else \n      cat(\"        no graphs\\n\")\n    if(object@options$save | object@options$save.graphs) cat(\"        directory where results are saved: \",object@options$directory,\"\\n\")\n    if(FALSE) {\n    if(length(object@rep.data)>0) irep<-1 else irep<-0\n    if(length(object@sim.data)>0) isim<-1 else isim<-0\n    if(irep>0 | isim>0) {\n      cat(\"-----------------------------------\\n\")\n      cat(\"----      Other components     ----\\n\")\n      cat(\"-----------------------------------\\n\")\n      if(irep>0) cat(\"    Replicated data on \",object@options$nb.chains,\" chains\\n\")\n      if(isim>0) cat(\"    Simulated data, \",object@options$nb.sim,\" simulations\\n\")\n    }\n    cat(\"-----------------------------------\\n\")\n  }\n  if(length(object@results@fixed.effects)>0) {\n    cat(\"----------------------------------------------------\\n\")\n    cat(\"----                  Results                   ----\\n\")\n    show(object@results)\n  }}\n)\n\n\n#' @exportMethod showall\n\n# Could be print, with only head of data\nsetMethod(\"showall\",\"SaemixObject\",\n  function(object) {\n#    cat(\"Object of class SaemixObject\\n\")\n    cat(\"Nonlinear mixed-effects model fit by the SAEM algorithm\\n\")\n    cat(\"-----------------------------------\\n\")\n    cat(\"----          Data             ----\\n\")\n    cat(\"-----------------------------------\\n\")\n    showall(object@data)\n    cat(\"-----------------------------------\\n\")\n    cat(\"----          Model            ----\\n\")\n    cat(\"-----------------------------------\\n\")\n    show(object@model)\n    cat(\"-----------------------------------\\n\")\n    cat(\"----      Algorithm options    ----\\n\")\n    cat(\"-----------------------------------\\n\")\n    if(object@options$map) cat(\"    Estimation of individual parameters (MAP)\\n\")\n    if(object@options$fim) cat(\"    Estimation of standard errors and linearised log-likelihood\\n\")\n    if(object@options$ll.is) cat(\"    Estimation of log-likelihood by importance sampling\\n\")\n    if(object@options$ll.gq) cat(\"    Estimation of log-likelihood by gaussian quadrature\\n\")\n    if(as.integer(object@options$map+object@options$fim+object@options$ll.is+object@options$ll.gq)==0) cat(\"    Algorithms: estimation only\\n\")\n    st1<-paste(c(\"K1=\",\"K2=\"),object@options$nbiter.saemix,sep=\"\",collapse=\", \")\n    cat(\"    Number of chains: \",object@options$nb.chains,\"\\n\")\n    cat(\"    Number of iterations: \",st1,\"\\n\")\n    cat(\"        nb of iterations for SA: \",object@options$nbiter.sa,\"\\n\")\n    cat(\"        nb of burning iterations: \",object@options$nbiter.burn,\"\\n\")\n    cat(\"    Seed:\\n\")\n    cat(\"        setting a random seed: \",!object@options$fix.seed,\"\\n\")\n    cat(\"        seed for the random number generator: \",object@options$seed,\"\\n\")\n    if(object@options$ll.is) {\n    \tcat(\"    Estimation of LL by Importance Sampling:\\n\")\n    \tcat(\"        number of MCMC samples: \",object@options$nmc.is,\"\\n\")\n    \tcat(\"        nu for IS: \",object@options$nu.is,\"\\n\")\n    \tcat(\"        produce plots during the estimation of LL by IS: \",object@options$print.is,\"\\n\")\n    }\n    cat(\"    Input/output\\n\")\n    cat(\"        display progress during the estimation process: \",object@options$displayProgress,\"\\n\")\n    cat(\"        nb of iterations after which to display progress: \",object@options$nbdisplay,\"\\n\")\n    cat(\"        print out the results after the fit: \",object@options$print,\"\\n\")\n    cat(\"        save the results to a file: \",object@options$save,\"\\n\")\n    cat(\"        save the graphs to files: \",object@options$save.graphs,\"\\n\")\n    if(object@options$save | object@options$save.graphs) cat(\"        directory where results should be saved: \",object@options$directory,\"\\n\")\n    cat(\"        whether warnings should be output during the fit: \",object@options$warnings,\"\\n\")\n    cat(\"    SAEM algorithm\\n\")\n    cat(\"        number of MCMC iterations for each kernel: \",object@options$nbiter.mcmc,\"\\n\")\n    cat(\"        probability of acceptance: \",object@options$proba.mcmc,\"\\n\")\n    cat(\"        : \",object@options$stepsize.rw,\"\\n\")\n    cat(\"        : \",object@options$rw.init,\"\\n\")\n    cat(\"        : \",object@options$alpha.sa,\"\\n\")\n    cat(\"        maximum nb of iterations for estimation of fixed effects: \",object@options$maxim.maxiter,\"\\n\")\n    if(object@options$ll.gq) {\n    \tcat(\"    Estimation of LL by Gaussian Quadrature:\\n\")\n    \tcat(\"        number of nodes: \",object@options$nnodes.gq,\"\\n\")\n    \tcat(\"        width of integral: \",object@options$nsd.gq,\"\\n\")\n    }\n    cat(\"    Simulations:\\n\")\n    cat(\"        nb of simulated datasets used for npde: \",object@options$nb.sim,\"\\n\")\n    cat(\"        nb of simulated datasets used for VPC: \",object@options$nb.simpred,\"\\n\")\n    cat(\"    Estimation of individual parameters\\n\")\n    cat(\"        nb of iterations: \",object@options$ipar.lmcmc,\"\\n\")\n    cat(\"        : \",object@options$ipar.rhomcmc,\"\\n\")\n    cat(\"        size of confidence interval: \",object@options$ipar.rmcmc,\"\\n\")\n    cat(\"-----------------------------------\\n\")\n    if(length(object@results@fixed.effects)>0) {\n      cat(\"----------------------------------------------------\\n\")\n      cat(\"----                  Results                   ----\\n\")\n      show(object@results)\n    }\n  }\n)\n\n####################################################################################\n####\t\t\tSaemixObject class - method to predict\t\t\t####\n####################################################################################\n\n#' @exportMethod predict\n\nsetMethod(f=\"predict\",\n  signature=\"SaemixObject\",\n  def=function(object,newdata=NULL,type=c(\"ipred\", \"ypred\", \"ppred\", \"icpred\"), se.fit=FALSE, ...) {\n    type<-match.arg(type)\n#    se.fit<-match.arg(se.fit) # doesn't work with logical type, change\n#    if(se.fit) cat(\"Currently predict() does not handle argument se.fit=TRUE.\\n\")\n    if(missing(newdata)) {\n      xpred<-fitted(object,type,...)\n      if(length(xpred)==0) {\n        namObj<-deparse(substitute(object))\n        opred<-saemix.predict(object)\n        assign(namObj,opred,envir=parent.frame()) # update object invisibly with predictions\n        xpred<-fitted(object,type,...)\n      }\n    } else {\n# Ignore type - when newdata is given, predictions correspond to the population predictions using the final estimates\n      id<-newdata[\"data\"][,newdata[\"name.group\"]]\n      if(length(newdata[\"name.covariates\"])==0) tab<-data.frame(id=id) else\n        tab<-data.frame(id=id,newdata[\"data\"][, newdata[\"name.covariates\",drop=FALSE]])\n      # Mcovariates: extract columns needed in the model\n      temp2<-unique(tab)\n      temp<-tab[!duplicated(id),,drop=FALSE]\n      if(dim(temp)[1]!=dim(temp2)[1]) cat(\"Some covariates have time-varying values; only the first is taken into account in the current version of the algorithm.\\n\")\n      #temp<-temp[order(temp[,1]),]\n      \n      if(length(newdata[\"name.covariates\"])>0) {\n        Mcovariates<-data.frame(id=rep(1,newdata[\"N\"]),temp[,2:dim(temp)[2]])} else {\n          Mcovariates<-data.frame(id=rep(1,newdata[\"N\"]))\n        }\n      j.cov<-which(rowSums(object[\"model\"][\"betaest.model\"])>0)\n      names(j.cov)[1]<-names(Mcovariates)[1]\n      Mcovariates<-Mcovariates[,names(j.cov),drop=FALSE] # eliminate all the unused covariates\n      for(icol in dim(Mcovariates)[2])\n        if(is.factor(Mcovariates[,icol])) Mcovariates[,icol]<-as.numeric(Mcovariates[,icol])-1\n      # COV: design matrix\n      COV<-matrix(nrow=dim(Mcovariates)[1],ncol=0)\n      for(j in 1:-object[\"model\"][\"nb.parameters\"]) {\n        jcov<-which(object[\"model\"][\"betaest.model\"][,j]==1)\n        aj<-as.matrix(Mcovariates[,jcov])\n        COV<-cbind(COV,aj)\n      }\n      # population parameters given by phi=Ci*mu (COV %*% Lcovariates) and psi=h(phi)\n      pop.phi<-COV %*% object[\"results\"][\"MCOV\"]\n      pop.psi<-transphi(pop.phi,object[\"model\"][\"transform.par\"])\n      structural.model<-object[\"model\"][\"model\"]\n      chdat<-new(Class=\"SaemixRepData\",data=newdata, nb.chains=1)\n      IdM<-chdat[\"dataM\"]$IdM\n      XM<-chdat[\"dataM\"][,newdata[\"name.predictors\"],drop=FALSE]\n      # Model predictions with pop.psi\n      fpred<-structural.model(pop.psi, IdM, XM)\n      if(object[\"model\"][\"error.model\"]==\"exponential\")\n        fpred<-log(cutoff(fpred))\n      xpred<-fpred\n    }\n    xpred\n  }\n)\n\n#' Compute model predictions after an saemix fit\n#' \n#' In nonlinear mixed effect models, different types of predictions may be obtained, including individual predictions and population predictions\n#' @param object an SaemixObject object\n#' @return an updated SaemixObject object\n#' @keywords methods\n#' @export saemix.predict\n\nsaemix.predict<-function(object) {\n  if(length(object[\"results\"][\"map.psi\"])==0)\n    object<-map.saemix(object)\n  # en principe n'arrive jamais car on les calcule pdt le fit...\n  if(length(object[\"results\"][\"cond.mean.phi\"])==0)\n    object<-conddist.saemix(object)\n  saemix.res<-object[\"results\"]\n  xind<-object[\"data\"][\"data\"][,object[\"data\"][\"name.predictors\"],drop=FALSE]\n  if(object[\"model\"][\"error.model\"]==\"exponential\") yobs<-object[\"data\"][\"yorig\"] else yobs<-object[\"data\"][\"data\"][,object[\"data\"][\"name.response\"]]\n  index<-object[\"data\"][\"data\"][,\"index\"]\n  # Individual predictions\n  ipred<-object[\"model\"][\"model\"](saemix.res[\"map.psi\"][, 2:dim(saemix.res[\"map.psi\"])[2]],index,xind)\n  ires<-object[\"data\"][\"data\"][,object[\"data\"][\"name.response\"]]-ipred\n  psiM<-transphi(saemix.res[\"cond.mean.phi\"],object[\"model\"][\"transform.par\"])\n  icond.pred<-object[\"model\"][\"model\"](psiM,index,xind)\n  saemix.res[\"ipred\"]<-ipred\n  saemix.res[\"icpred\"]<-icond.pred\n  # Individual weighted residuals\n  pres<-saemix.res[\"respar\"]\n  gpred<-error(ipred,pres)\n  iwres<-(ipred-yobs)/gpred\n  gpred<-error(icond.pred,pres)\n  icwres<-(icond.pred-yobs)/gpred\n  saemix.res[\"iwres\"]<-iwres\n  saemix.res[\"icwres\"]<-icwres\n  # Population predictions using the population parameters [ f(mu) ]\n  psiM<-transphi(saemix.res[\"mean.phi\"],object[\"model\"][\"transform.par\"])\n  ppred<-object[\"model\"][\"model\"](psiM,index,xind)\n  saemix.res[\"ppred\"]<-ppred\n  if(length(saemix.res[\"predictions\"])==0) \n    saemix.res[\"predictions\"]<-data.frame(ppred=ppred,ipred=ipred,icpred=icond.pred,ires=ires,iwres=iwres,icwres=icwres) else {\n      saemix.res[\"predictions\"]$ppred<-ppred\n      saemix.res[\"predictions\"]$ipred<-ipred\n      saemix.res[\"predictions\"]$icpred<-icond.pred\n      saemix.res[\"predictions\"]$ires<-ires\n      saemix.res[\"predictions\"]$iwres<-iwres\n      saemix.res[\"predictions\"]$icwres<-icwres\n    }\n  # Population weighted residuals: needs the individual variance-covariance matrix => use compute.sres to estimate these by simulations\n  object[\"results\"]<-saemix.res\n  return(object)\n}\n\n####################################################################################\n####\t\t\tSaemixObject class - method to plot\t\t\t####\n####################################################################################\n#' General plot function from SAEM\n#' \n#' Several plots (selectable by the type argument) are currently available:\n#' convergence plot, individual plots, predictions versus observations,\n#' distribution plots, VPC, residual plots.\n#' \n#' This is the generic plot function for an SaemixObject object, which\n#' implements different graphs related to the algorithm (convergence plots,\n#' likelihood estimation) as well as diagnostic graphs. A description is\n#' provided in the PDF documentation. Arguments such as main, xlab, etc... that\n#' can be given to the generic plot function may be used, and will be\n#' interpreted according to the type of plot that is to be drawn.\n#' \n#' A special argument plot.type can be set to determine the type of plot; it\n#' can be one of: \n#' \\describe{ \n#' \\item{data:}{A spaghetti plot of the data,displaying the observed data y \n#' as a function of the regression variable (time for a PK application)} \n#' \\item{convergence:}{For each parameter in the model, this plot shows the \n#' evolution of the parameter estimate versus the iteration number} \n#' \\item{likelihood:}{Graph showing the evolution of the\n#' log-likelihood during the estimation by importance sampling}\n#' \\item{observations.vs.predictions:}{Plot of the predictions computed with\n#' the population parameters versus the observations (left), and plot of the\n#' predictions computed with the individual parameters versus the observations (right)} \n#' \\item{residuals.scatter:}{Scatterplot of the residuals versus the\n#' predictor (top) and versus predictions (bottom), for weighted residuals\n#' (population residuals, left), individual weighted residuals (middle) and npde (right).} \n#' \\item{residuals.distribution:}{Distribution of the residuals,\n#' plotted as histogram (top) and as a QQ-plot (bottom), for weighted residuals\n#' (population residuals, left), individual weighted residuals (middle) and npde (right).} \n#' \\item{individual.fit:}{Individual fits are obtained using the\n#' individual parameters with the individual covariates}\n#' \\item{population.fit:}{Population fits are obtained using the population\n#' parameters with the individual covariates} \n#' \\item{both.fit:}{Individual fits, superposing fits obtained using the population \n#' parameters with the individual covariates (red) and using the individual parameters \n#' with the individual covariates (green)} \n#' \\item{marginal.distribution:}{Distribution of\n#' the parameters (conditional on covariates when some are included in the\n#' model). A histogram of individual parameter estimates can be overlayed on\n#' the plot, but it should be noted that the histogram does not make sense when\n#' there are covariates influencing the parameters and a warning will be\n#' displayed} \n#' \\item{random.effects:}{Boxplot of the random effects}\n#' \\item{correlations:}{Correlation between the random effects}\n#' \\item{parameters.vs.covariates:}{Plots of the estimates of the individual\n#' parameters versus the covariates, using scatterplot for continuous\n#' covariates, boxplot for categorical covariates}\n#' \\item{randeff.vs.covariates:}{Plots of the estimates of the random effects\n#' versus the covariates, using scatterplot for continuous covariates, boxplot\n#' for categorical covariates} \n#' \\item{npde:}{Plots 4 graphs to evaluate the shape of the distribution of the \n#' normalised prediction distribution errors (npde)} \n#' \\item{vpc:}{Visual Predictive Check, with options to include the\n#' prediction intervals around the boundaries of the selected interval as well\n#' as around the median (50th percentile of the simulated data).} \n#' } \n#' In addition, the following values for plot.type produce a series of plots:\n#' \\describe{ \n#' \\item{reduced:}{ produces the following plots: plot of the data,\n#' convergence plots, plot of the likelihood by importance sampling (if\n#' computed), plots of observations versus predictions. This is the default\n#' behaviour of the plot function applied to an SaemixObject object}\n#' \\item{full:}{ produces the following plots: plot of the data, convergence\n#' plots, plot of the likelihood by importance sampling (if computed), plots of\n#' observations versus predictions, scatterplots and distribution of residuals,\n#' VPC, npde, boxplot of the random effects, distribution of the parameters,\n#' correlations between random effects, plots of the relationships between\n#' individually estimated parameters and covariates, plots of the relationships\n#' between individually estimated random effects and covariates}\n#' \n#' Each plot can be customised by modifying options, either through a list of\n#' options set by the \\code{\\link{saemix.plot.setoptions}} function, or on the\n#' fly by passing an option in the call to the plot (see examples). \n#' }\n#' \n#' @aliases plot.saemix plot,SaemixObject plot\n#' @param x an object returned by the \\code{\\link{saemix}} function\n#' @param y empty\n#' @param \\dots optional arguments passed to the plots\n#' @return None\n#' @author Emmanuelle Comets <emmanuelle.comets@@inserm.fr>, Audrey Lavenu,\n#' Marc Lavielle.\n#' @seealso \\code{\\link{SaemixObject}},\\code{\\link{saemix}},\n#' \\code{\\link{saemix.plot.setoptions}}, \\code{\\link{saemix.plot.select}},\n#' \\code{\\link{saemix.plot.data}}\n#' @references Kuhn E, Lavielle M. Maximum likelihood estimation in nonlinear\n#' mixed effects models. Computational Statistics and Data Analysis 49, 4\n#' (2005), 1020-1038.\n#' \n#' Comets E, Lavenu A, Lavielle M. SAEMIX, an R version of the SAEM algorithm.\n#' 20th meeting of the Population Approach Group in Europe, Athens, Greece\n#' (2011), Abstr 2173.\n#' @keywords plot\n#' @examples\n#' \n#' data(theo.saemix)\n#' \n#' saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=\" \",na=NA, \n#'   name.group=c(\"Id\"),name.predictors=c(\"Dose\",\"Time\"),\n#'   name.response=c(\"Concentration\"),name.covariates=c(\"Weight\",\"Sex\"),\n#'   units=list(x=\"hr\",y=\"mg/L\",covariates=c(\"kg\",\"-\")), name.X=\"Time\")\n#' \n#' model1cpt<-function(psi,id,xidep) { \n#' \t  dose<-xidep[,1]\n#' \t  tim<-xidep[,2]  \n#' \t  ka<-psi[id,1]\n#' \t  V<-psi[id,2]\n#' \t  CL<-psi[id,3]\n#' \t  k<-CL/V\n#' \t  ypred<-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))\n#' \t  return(ypred)\n#' }\n#' \n#' saemix.model<-saemixModel(model=model1cpt,\n#'   description=\"One-compartment model with first-order absorption\", \n#'   psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,\n#'   dimnames=list(NULL, c(\"ka\",\"V\",\"CL\"))),transform.par=c(1,1,1),\n#'   covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),\n#'   covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),\n#'   omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model=\"constant\")\n#' \n#' saemix.options<-list(seed=632545,save=FALSE,save.graphs=FALSE)\n#' \n#' # Not run (strict time constraints for CRAN)\n#' # saemix.fit<-saemix(saemix.model,saemix.data,saemix.options)\n#' \n#' # Set of default plots\n#' # plot(saemix.fit)\n#' \n#' # Data\n#' # plot(saemix.fit,plot.type=\"data\")\n#' \n#' # Convergence\n#' # plot(saemix.fit,plot.type=\"convergence\")\n#' \n#' # Individual plot for subject 1, smoothed\n#' # plot(saemix.fit,plot.type=\"individual.fit\",ilist=1,smooth=TRUE)\n#' \n#' # Individual plot for subject 1 to 12, with ask set to TRUE \n#' # (the system will pause before a new graph is produced)\n#' # plot(saemix.fit,plot.type=\"individual.fit\",ilist=c(1:12),ask=TRUE)\n#' \n#' # Diagnostic plot: observations versus population predictions\n#' # par(mfrow=c(1,1))\n#' # plot(saemix.fit,plot.type=\"observations.vs.predictions\",level=0,new=FALSE)\n#' \n#' # LL by Importance Sampling\n#' # plot(saemix.fit,plot.type=\"likelihood\")\n#' \n#' # Scatter plot of residuals\n#' # Data will be simulated to compute weighted residuals and npde\n#' # the results shall be silently added to the object saemix.fit\n#' # plot(saemix.fit,plot.type=\"residuals.scatter\")\n#' \n#' # Boxplot of random effects\n#' # plot(saemix.fit,plot.type=\"random.effects\")\n#' \n#' # Relationships between parameters and covariates\n#' # plot(saemix.fit,plot.type=\"parameters.vs.covariates\")\n#' \n#' # Relationships between parameters and covariates, on the same page\n#' # par(mfrow=c(3,2))\n#' # plot(saemix.fit,plot.type=\"parameters.vs.covariates\",new=FALSE)\n#' \n#' # VPC\n#' # Not run (time constraints for CRAN)\n#' # plot(saemix.fit,plot.type=\"vpc\")\n#' \n#' @exportMethod plot\n\nsetMethod(f=\"plot\",\n  signature=\"SaemixObject\",\n  def=function(x,y,...) {\n    args1<-match.call(expand.dots=TRUE)\n    i1<-match(\"plot.type\",names(args1))\n    if(!is.na(i1)) {\n      plot.type<-as.character(args1[[i1]])\n      plot.type<-plot.type[plot.type!=\"c\"]\n    } else plot.type<-\"reduced\"\n#    cat(\"plot.type=\",plot.type,\"\\n\")\n    if(plot.type[1]==\"reduced\") plot.type<-c(\"data\",\"convergence\",\"likelihood\", \"observations.vs.predictions\")\n    if(plot.type[1]==\"full\") plot.type<-c(\"data\",\"convergence\",\"likelihood\", \"observations.vs.predictions\",\"residuals.scatter\",\"residuals.distribution\",\"vpc\")\n    \n    pltyp<-c(\"data\",\"convergence\",\"likelihood\",\"individual.fit\", \"population.fit\", \"both.fit\",\"observations.vs.predictions\",\"residuals.scatter\", \"residuals.distribution\",\"vpc\",\"npde\",\"random.effects\",\"marginal.distribution\", \"correlations\",\"parameters.vs.covariates\",\"randeff.vs.covariates\")\n    ifnd<-pmatch(plot.type,pltyp)\n    if(sum(is.na(ifnd))>0) {\n      cat(\"The following plot types were not found or are ambiguous:\", plot.type[is.na(ifnd)],\"\\n\")\n    }\n    ifnd<-ifnd[!is.na(ifnd)]\n    if(length(ifnd)==0) return()\n    plot.type<-pltyp[ifnd]\n    interactive<-x[\"prefs\"]$interactive\n    id.pred<-match(plot.type,c(\"observations.vs.predictions\",\"individual.fit\", \"residuals.scatter\",\"residuals.distribution\"))\n    if(x@prefs$which.poppred==\"ppred\") id.pred<-c(id.pred,match(plot.type, c(\"population.fit\", \"both.fit\")))\n    id.map<-match(plot.type,c(\"randeff.vs.covariates\",\"parameters.vs.covariates\"))\n    id.sim<-match(plot.type, c(\"vpc\"))\n    id.res<-match(plot.type, c(\"npde\",\"residuals.scatter\", \"residuals.distribution\"))\n    if(x@prefs$which.poppred==\"ypred\") id.sim<-c(id.sim,match(plot.type, c(\"population.fit\", \"both.fit\")))\n    id.pred<-id.pred[!is.na(id.pred)]\n    id.sim<-id.sim[!is.na(id.sim)]\n    id.map<-id.map[!is.na(id.map)]\n    id.res<-id.res[!is.na(id.res)]\n    namObj<-deparse(substitute(x))\n#    cat(namObj,\"\\n\")\n    if(length(id.pred)>0) {\n      if(length(x[\"results\"][\"ipred\"])==0 | length(x[\"results\"][\"iwres\"])) {\n        boolpred<-TRUE\n        if(interactive) {\n      cok<-readline(prompt=\"Computations will be performed to obtain model predictions, proceed ? (y/Y) [default=yes] \")\n        if(!cok %in% c(\"y\",\"Y\",\"yes\",\"\")) return()\n        }\n        if(boolpred) {\n          x<-saemix.predict(x)\n          assign(namObj,x,envir=parent.frame())\n        }\n      }\n    }\n    if(length(id.sim)>0) {\n      if(length(x[\"sim.data\"][\"N\"])==0 || x[\"sim.data\"][\"nsim\"]==0) {\n        boolpred<-TRUE\n        if(interactive) {\n        cok<-readline(prompt=\"Simulations will be performed. This might take a while, proceed ? (y/Y) [default=yes] \")\n        if(!cok %in% c(\"y\",\"Y\",\"yes\",\"\")) return()\n        } else {\n        \tcat(\"Performing simulations under the model.\\n\")\n        }\n        if(boolpred) {\n          x<-simul.saemix(x)\n          assign(namObj,x,envir=parent.frame())\n        }\n      }\n    }\n    if(length(id.res)>0) {\n      if(length(x[\"results\"][\"npde\"])==0) {\n        boolpred<-TRUE\n        if(interactive) {\n        cok<-readline(prompt=\"Simulations will be performed to obtain residuals, VPC and npde. This might take a while, proceed ? (y/Y) [default=yes] \")\n        if(!cok %in% c(\"y\",\"Y\",\"yes\",\"\")) return()\n        }\n        if(boolpred) {\n          x<-compute.sres(x)\n          assign(namObj,x,envir=parent.frame())\n        }\n      }\n    }\n    if(length(id.map)>0) {\n      if(length(x[\"results\"][\"map.eta\"])==0) {\n        cat(\"Computing ETA estimates and adding them to fitted object.\\n\")\n\tx<-compute.eta.map(x)\n        assign(namObj,x,envir=parent.frame())\n      }\n    }\n    for(ipl in plot.type) {\n      switch (EXPR=ipl,\n    \"data\"={\n       cat(\"Plotting the data\\n\")\n       saemix.plot.data(x,...)\n    },\n    \"convergence\"={\n       cat(\"Plotting convergence plots\\n\")\n       saemix.plot.convergence(x,...)\n    },\n    \"likelihood\"={  \n       cat(\"Plotting the likelihood\\n\")\n       saemix.plot.llis(x,...)\n    },\n    \"observations.vs.predictions\"={\n       cat(\"Plotting observations versus predictions\\n\")      \n       saemix.plot.obsvspred(x,...)\n    },\n    \"individual.fit\"={\n      cat(\"Plotting individual fits\\n\")\n      saemix.plot.fits(x,...)\n    },\n    \"population.fit\"={\n      cat(\"Plotting fits obtained with population predictions\\n\")\n      saemix.plot.fits(x,level=0,...)\n    },\n    \"both.fit\"={\n      cat(\"Plotting the fits overlaying individual and population predictions\\n\")\n      saemix.plot.fits(x,level=c(0,1),...)\n    },\n    \"residuals.scatter\"={\n      cat(\"Plotting scatterplots of residuals\\n\")\n      saemix.plot.scatterresiduals(x,...)\n    },\n    \"residuals.distribution\"={\n      cat(\"Plotting the distribution of residuals\\n\")\n      saemix.plot.distribresiduals(x,...)\n    },\n    \"random.effects\"={\n      saemix.plot.randeff(x,...)\n    },\n    \"correlations\"={\n      if(length(x@model@indx.omega>1)) saemix.plot.correlations(x,...)\n    },\n    \"parameters.vs.covariates\"={\n      if(length(x@data@name.covariates)==0) {\n        cat(\"No covariates in the dataset\\n\")\n        return()\n      } else saemix.plot.parcov(x,...)\n    },\n    \"randeff.vs.covariates\"={\n      if(length(x@data@name.covariates)==0) {\n        cat(\"No covariates in the dataset\\n\")\n        return()\n      } else saemix.plot.randeffcov(x,...)\n    },\n    \"marginal.distribution\"={\n      saemix.plot.distpsi(x,...)\n    },\n    \"vpc\"={\n      cat(\"Plotting VPC\\n\")\n      saemix.plot.vpc(x,...)\n    },\n    \"npde\"={\n      cat(\"Plotting npde\\n\")\n      saemix.plot.npde(x,...)\n    },\n    cat(\"Plot \",ipl,\" not implemented yet\\n\")\n     )\n   }\n  }\n)\n\n####################################################################################\n####\t\t\tLikelihood and tests\t\t####\n####################################################################################\n\n##' Extract likelihood from a saemixObject resulting from a call to saemix\n##'\n##' The likelihood in saemix can be computed by one of three methods: linearisation (linearisation of the model), importance sampling (stochastic integration) and gaussian quadrature (numerical integration). The linearised likelihood is obtained as a byproduct of the computation of the Fisher Information Matrix (argument FIM=TRUE in the options given to the saemix function).\n##' If no method argument is given, this function will attempt to extract the likelihood computed by importance sampling (method=\"is\"), unless the object contains the likelihood computed by linearisation, in which case the function will extract this component instead.\n##' If the requested likelihood is not present in the object, it will be computed and aded to the object before returning.\n##'\n##' @name logLik\n##' @aliases AIC.SaemixObject BIC.SaemixObject logLik.SaemixObject\n##'\n##' @param object name of an SaemixObject object\n##' @param method character string, one of c(\"is\",\"lin\",\"gq\"), to select one of the available approximations to the log-likelihood (is: Importance Sampling; lin: linearisation and gq: Gaussian Quadrature). See documentation for details\n##' @param ... additional arguments\n##' @param k numeric, the penalty per parameter to be used; the default k = 2 is the classical AIC\n##' @return Returns the selected statistical criterion (log-likelihood, AIC, BIC) extracted from the SaemixObject, computed with the 'method' argument if given (defaults to IS).\n##' @references Kuhn E, Lavielle M. Maximum likelihood estimation in nonlinear mixed effects models. Computational Statistics and Data Analysis 49, 4 (2005), 1020-1038.\n##' \n##' Comets E, Lavenu A, Lavielle M. SAEMIX, an R version of the SAEM algorithm. 20th meeting of the Population Approach Group in Europe, Athens, Greece (2011), Abstr 2173.\n#' @author Emmanuelle Comets \\email{emmanuelle.comets@@inserm.fr}\n#' @author Audrey Lavenu\n#' @author Marc Lavielle.\n#' @seealso \\code{\\link{AIC}},\\code{\\link{BIC}}, \\code{\\link{saemixControl}}, \\code{\\link{saemix}}\n#' @docType methods\n#' @keywords methods\n#' @export logLik.SaemixObject\n\n## log-likelihood for SaemixObject objects\nlogLik.SaemixObject<- function(object, method=\"is\", ...) {\n#   args1<-match.call(expand.dots=TRUE)\n#   i1<-match(\"method\",names(args1))\n#   if(!is.na(i1)) {\n#     str1<-as.character(args1[[i1]])\n#     if(str1 %in% c(\"is\",\"lin\",\"gq\")) method<-str1\n#   } else {\n#     if(length(object@results@ll.is)!=0 | length(object@results@ll.lin)==0) method<-\"is\" else method<-\"lin\"\n#   }\n  # Compute the requested LL if not present\n  namObj<-deparse(substitute(object))\n  if(method==\"is\" & length(object@results@ll.is)==0) {\n    object<-llis.saemix(object)\n    assign(namObj,object,envir=parent.frame())\n  }\n  if(method==\"gq\" & length(object@results@ll.gq)==0) {\n    object<-llgq.saemix(object)\n    assign(namObj,object,envir=parent.frame())\n  }\n  if(method==\"lin\" & length(object@results@ll.lin)==0) {\n    object<-fim.saemix(object)\n    assign(namObj,object,envir=parent.frame())\n  }\n  # OR: return if desired LL has not been computed\n  #     if(method==\"gq\" & length(object@results@ll.gq)==0) {\n  #     \tcat(\"The log-likelihood by Gaussian Quadrature has not yet been computed.\\n\")\n  #     \tinvisible(NULL)\n  #     }\n  #     if(method==\"is\" & length(object@results@ll.is)==0) {\n  #     \tcat(\"The log-likelihood by Importance Sampling has not yet been computed.\\n\")\n  #     \tinvisible(NULL)\n  #     }\n  #     if(method==\"lin\" & length(object@results@ll.lin)==0) {\n  #     \tcat(\"The log-likelihood by linearisation has not yet been computed.\\n\")\n  #     \tinvisible(NULL)\n  #     }\n  val<-switch(method,is=object@results@ll.is,lin=object@results@ll.lin, gq=object@results@ll.gq)\n  res<-paste(format(val,digits=2,nsmall=2),\" (df=\",object@results@npar.est,\")\", sep=\"\")\n  res<-matrix(res,dimnames=list(paste(\"LL by\",method),\" \"))\n  print(res)\n  attr(val, \"nall\") <- object@data@N\n  attr(val, \"nobs\") <- object@data@ntot.obs\n  attr(val, \"df\") <- object@results@npar.est\n  class(val) <- \"logLik\"\n  val\n}\n\n#' @export AIC.SaemixObject\n#' @rdname logLik\n\nAIC.SaemixObject<-function(object, ..., k=2) {\n  args1<-match.call(expand.dots=TRUE)\n  i1<-match(\"method\",names(args1))\n  if(!is.na(i1)) {\n    str1<-as.character(args1[[i1]])\n    if(str1 %in% c(\"is\",\"lin\",\"gq\")) method<-str1\n  } else {\n    if(length(object@results@ll.is)!=0 | length(object@results@ll.lin)==0) method<-\"is\" else method<-\"lin\"\n  }\n  # Compute the requested LL if not present\n  namObj<-deparse(substitute(object))\n  if(method==\"is\" & length(object@results@ll.is)==0) {\n    object<-llis.saemix(object)\n    assign(namObj,object,envir=parent.frame())\n  }\n  if(method==\"gq\" & length(object@results@ll.gq)==0) {\n    object<-llgq.saemix(object)\n    assign(namObj,object,envir=parent.frame())\n  }\n  if(method==\"lin\" & length(object@results@ll.lin)==0) {\n    object<-fim.saemix(object)\n    assign(namObj,object,envir=parent.frame())\n  }\n  val<-switch(method,is=object@results@aic.is,lin=object@results@aic.lin, gq=object@results@aic.gq)\n  val\n}\n\n#' @export BIC.SaemixObject\n#' @rdname logLik\n\nBIC.SaemixObject<-function(object, ...) {\n#  -2 * as.numeric(object) + attr(object, \"df\") * log(nobs(object))\n  args1<-match.call(expand.dots=TRUE)\n  i1<-match(\"method\",names(args1))\n  if(!is.na(i1)) {\n    str1<-as.character(args1[[i1]])\n    if(str1 %in% c(\"is\",\"lin\",\"gq\")) method<-str1\n  } else {\n    if(length(object@results@ll.is)!=0 | length(object@results@ll.lin)==0) method<-\"is\" else method<-\"lin\"\n  }\n  # Compute the requested LL if not present\n  namObj<-deparse(substitute(object))\n  if(method==\"is\" & length(object@results@ll.is)==0) {\n    object<-llis.saemix(object)\n    assign(namObj,object,envir=parent.frame())\n  }\n  if(method==\"gq\" & length(object@results@ll.gq)==0) {\n    object<-llgq.saemix(object)\n    assign(namObj,object,envir=parent.frame())\n  }\n  if(method==\"lin\" & length(object@results@ll.lin)==0) {\n    object<-fim.saemix(object)\n    assign(namObj,object,envir=parent.frame())\n  }\n  val<-switch(method,is=object@results@bic.is,lin=object@results@bic.lin, gq=object@results@bic.gq)\n  val\n}\n\n# Log-likelihood ratio test, given 2 models\n# ECO TODO\n\n####################################################################################\n####\t\t\tsaemixObject class - accesseurs parametres\t\t####\n####################################################################################\n#' @rdname psi-methods\n#' @exportMethod psi\n\n# Extract individual parameter estimates (psi_i)\nsetMethod(\"psi\",\"SaemixObject\",\n  function(object,type=c(\"map\",\"mode\")) {\n    namObj<-deparse(substitute(object))\n    if(type==\"map\") { # mode\n      if(length(object@results@map.psi)==0) {\n        object<-map.saemix(object)\n        assign(namObj,object,envir=parent.frame())\n      }\n      psi<-object@results@map.psi[,-c(1)]\n    } else { # conditional means\n      if(length(object@results@cond.mean.psi)==0) {\n        object<-conddist.saemix(object)\n        assign(namObj,object,envir=parent.frame())\n      }\n      psi<-object@results@cond.mean.psi\n    }\n    return(psi)\n  }\n)\n\n#' @rdname psi-methods\n#' @exportMethod phi\n\n# Extract individual parameter estimates on non-transformed scale (phi_i)\nsetMethod(\"phi\",\"SaemixObject\",\n  function(object,type=c(\"map\",\"mode\")) {\n    namObj<-deparse(substitute(object))\n    if(type==\"map\") { # mode\n      if(length(object@results@map.phi)==0) {\n        object<-map.saemix(object)\n        assign(namObj,object,envir=parent.frame())\n      }\n      phi<-object@results@map.phi[,-c(1)]\n    } else { # conditional means\n      if(length(object@results@cond.mean.phi)==0) {\n        object<-conddist.saemix(object)\n        assign(namObj,object,envir=parent.frame())\n      }\n      phi<-object@results@cond.mean.phi\n    }\n    return(phi)\n  }\n)\n\n# Extract individual estimates of random effects (eta_i)\n#' @rdname psi-methods\n#' @exportMethod eta\n\nsetMethod(\"eta\",\"SaemixObject\",\n  function(object,type=c(\"map\",\"mode\")) {\n    namObj<-deparse(substitute(object))\n#    cat(\"Nom objet\",namObj,\"\\n\")\n    if(type==\"map\") { # mode\n      if(length(object@results@map.eta)==0) {\n        object<-compute.eta.map(object)\n        assign(namObj,object,envir=parent.frame())\n      }\n      eta<-object@results@map.eta[,-c(1)]\n    } else { # conditional means\n      if(length(object@results@cond.mean.eta)==0) {\n        object<-conddist.saemix(object)\n        assign(namObj,object,envir=parent.frame())\n      }\n      eta<-object@results@cond.mean.eta\n    }\n    return(eta)\n  }\n)\n\n#' Extract coefficients from a saemix fit\n#' \n#' @name coef.saemix\n#' @aliases coef coef.SaemixObject\n#' @aliases coef,SaemixObject coef,SaemixObject-method\n#' @param object a SaemixObject\n#' @param ... further arguments to be passed to or from other methods\n#' @return a list with 3 components:\n#' \\describe{\n#' \\item{fixed}{fixed effects}\n#' \\item{population}{a list of population parameters with two elements, a matrix containing the untransformed parameters psi and a matrix containing the transformed parameters phi}\n#' \\item{individual}{a list of individual parameters with two elements, a matrix containing the untransformed parameters psi and a matrix containing the transformed parameters phi}\n#' }\n#' @export coef.SaemixObject\n\ncoef.SaemixObject<-function(object, ...) {\n#    if(missing(level)) level<-1\n    pfix<-object@results@fixed.effects[object@results@indx.fix]\n    names(pfix)<-object@results@name.fixed[object@results@indx.fix]\n#c(object@results@fixed.effects,object@name.res[object@indx.res])\n#    names(pfix)<-c(object@results@name.fixed,object@name.res[object@indx.res])    \n    pop.phi<-object@results@mean.phi\n    pop.psi<-transphi(pop.phi,object@model@transform.par)\n    ind.psi<-list(map=object@results@map.psi[,-c(1)], cond=object@results@cond.mean.psi)\n    ind.phi<-list(map=object@results@map.phi[,-c(1)], cond=object@results@cond.mean.phi)\n    eta<-list(map=object@results@map.eta[,-c(1)],cond=object@results@cond.mean.eta)\n    colnames(pop.phi)<-colnames(pop.psi)<-colnames(ind.phi$map)<-names(pfix)\n    colnames(ind.psi$map)<-colnames(ind.phi$cond)<-colnames(ind.psi$cond)<-names(pfix)\n    coef<-list(fixed=pfix,population=list(psi=pop.psi,phi=pop.phi), individual=list(psi=ind.psi,phi=ind.phi,eta=eta))\n    return(coef)\n  }\n\n#' @rdname resid.saemix\n#' @export resid.SaemixObject\n\n# Extract residuals and fitted\nresid.SaemixObject<-function (object, type = c(\"ires\", \"wres\", \"npde\", \"pd\", \"iwres\", \"icwres\"), ...) {\n  type <- match.arg(type)\n  resid(object@results, type=type, ...)\n}\n\n#' @rdname fitted.saemix\n#' @export fitted.SaemixObject\n\nfitted.SaemixObject<-function (object, type = c(\"ipred\", \"ypred\", \"ppred\", \"icpred\"), ...) \n          {\n            type <- match.arg(type)\n            fitted(object@results, type=type, ...)\n          }\n\n####################################################################################\n",
    "created" : 1511872049655.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3462309771",
    "id" : "3D997BCE",
    "lastKnownWriteTime" : 1512311332,
    "last_content_update" : 1512311332,
    "path" : "~/Desktop/package_contrib/saemixB/R/SaemixObject.R",
    "project_path" : "R/SaemixObject.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}