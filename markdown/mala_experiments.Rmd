---
title: "Mala experiments"
output:
  html_document: default
  pdf_document: default
header-includes:
- \usepackage{bbm}
- \usepackage{amsmath}
- \usepackage{amsmath,amssymb,amsthm,mathrsfs,amsfonts,dsfont}
- \usepackage[utf8]{inputenc}
- \usepackage[T1]{fontenc}
- \usepackage[french]{babel}
- \usepackage{enumitem}
---
$\newcommand{\expec}{\mathbb{E}}$
$\newcommand{\prob}{\mathbb{P}}$
$\newcommand{\indic}{\mathbb{1}}$
$\DeclareMathOperator*{\argmax}{arg\,max}$

In this document, we will deal with the MALA and variants algorithms such as: MALA, Nesterov, Adaptive MALA, Anisotropic MALA, Non reversible MALA. The second part will deal with an improvment of the diffusion taking into considerantion non smoothness of the potential we are sampling.

# The Model
We study a classical missing data problem where:

* The observed data is a continuous random variable $Y = (Y_i, 1\leq i \leq N)$ that has observed values $(y_i, 1\leq i \leq N)$ in $\mathcal{Y}$
* The latent data is a continuous random variable $\psi = (\psi_i, 1\leq i \leq N)$ that takes on the values $(\psi_i, 1\leq i \leq N)$ in $\mathcal{Z}$ and consists in $N$ independent variables
* The components $Y_i$ are generated independently of each other and from their corresponding $\psi_i$
* $\log p(y,\theta)$ is the incomplete data log-likelihood
* $\log p(y,z,\theta)$ is the complete data log-likelihood and obtained by augmenting the observed data with the missing data
* We'll call $P_{Y_i,\psi_i,\theta}$ and $P_{\psi_i|Y_i,\theta}$ the probability distributions associated to the densities $p(y_i,\psi_i,\theta)$ and $p(\psi_i|y_i,\theta)$

Our objective is to create samples from the posterior distribiution $P_{\psi_i|Y_i,\theta}$ for all individuals i and at a fixed model parameter $\theta$.


In this document, we will consider N i.i.d. observations $y=(y_i, 1\leqslant i \leqslant N)$, unobserved individuals parameters $\psi=(\psi_i, 1\leqslant i \leqslant N)$ and a vector of parameters $\theta$.
The goal is to find the parameter $\theta$ that maximizes the likelihood $p(y;\theta)$:

$$p(y;\theta) = \int_{}^{} p(y,\psi;\theta) \, \mathrm{d}\psi$$

We are going to restrict ourselves to models that belong to the exponential family.
The complete data log likelihood can be expressed as:

$$\log p(y, \psi; \theta) = -\phi(\theta) + \langle S(y,\psi){,} \Phi(\theta) \rangle$$

With $\langle \cdot{,} \cdot \rangle$ being the scalar product and $\phi(\theta)$, $\Phi(\theta)$ and $S(y,\psi)$ are known functions.\\
We consider a joint model for the observations $y = (y_i, 1\leqslant i \leqslant N)$ and the individual parameters $\psi = (\psi_i, 1\leqslant i \leqslant N)$:
$$p(y, \psi; \theta) = p(y|\psi; \theta)p(\psi; \theta)$$
Where $p(y|\psi; \theta)$ is the conditional distribution of the observations of individual $i$ and $p(\psi; \theta)$ the distribution of the individual parameters.
Also:

\begin{split}
& y_i = f(t_i)+\sigma\epsilon_i \textrm{ with $\epsilon_i\sim \mathcal{N}(0,1)$}\\
&\psi_i = c_i*\psi_{pop}+\eta_i\textrm{ with $\eta_i\sim \mathcal{N}(0,\Omega)$}
\end{split}
\end{equation}
$f$ is a non linear function solution of a PK-PD Ordinary Differential Equation.\\
As a result we have the following hierarchical model:

\begin{split}
& y_i|\psi_i \sim \mathcal{N}(f(t),\sigma)\\
& \psi_i \sim \mathcal{N}(\psi_{pop}, \Omega)
\end{split}

#MALA and variants
##Mala
In this section, we will describe an MCMC method that consists in constructing a Markov chain based on the discretized Langevin diffusion. Samples are accepted and rejected thanks to a MH step.
Let denote $\pi$ the distibution we want to sample from. In our case it is the conditional density $p(\psi|y;\theta)$.
We consider the overdamped Langevin diffusion:

$$\dot{X} = \nabla \log \pi(X) + \sqrt{2}\dot{W}$$

This diffusion is driven by the time derivative of a Brownian motion W.
It is proven that this diffusion admits as stationary distribution $\pi$.
We'll use the Euler-Maruyama discretization of this diffusion such as:

$$X_{k+1} = X_k + \gamma\nabla\log\pi(X) + \sqrt{2\gamma}Z$$

$\gamma > 0$ is the discretization step.

The algorithm consists then in drawing a sample candidate from the Langevin proposal (basically a gaussian, implied by the brownian motion, centered in $X_k + \gamma\nabla\log\pi(X)$ with variance $\sqrt{2\gamma}$) and applying an MH step.


$$\eta_i^k = \eta_i^{k-1}+\gamma\nabla\log\pi(\eta_i^{k-1}+\sqrt{2\gamma} Z \textrm{ with }Z \sim \mathcal{N}(0,1)$$


And the acceptance ratio:
$$
\begin{split}
\alpha(\eta_i^{k},\eta_i^{k-1}) = \frac{q(\eta_i^{k-1}|\eta_i^{k})p_{\eta_i}(\eta_i^{k})p_{y_i|\eta_i}(\eta_i^{k})}{q(\eta_{k}|\eta_i^{k-1})p_{\eta_i}(\eta_i^{k-1})p_{y_i|\eta_i}(\eta_i^{k-1})}
\end{split}
$$
With $q(.)$ being the proposal distribution.
Here again, in our implementation the adaptive stepsize $\gamma$ updates consists in (cf Atachad√© adaptive MALA):

$$\gamma = \gamma (1+\delta(\alpha(\eta_i^{k},\eta_i^{k-1})-\alpha^{*}))$$

The stationnary distribution of that Markov Chain is the conditional distribution we intended to sample from.

###Theophylline (12 individuals 10 observations per individual)

Beforehand, the standard approach is to approximate the body as a simple compartment models. In this example we will focus on a one-compartment model for theophylline following oral dose D at time $t=0$ leading to description of concentration $y(t_i)$ at time $t_i \geq 0$ (i varies from 1 to N and denote the individual of the population):
$$
y_i = y(t_i) = f(\psi_i)+ \epsilon_i
$$
With :

$$f(\psi_i) = \frac{D(k_a)_i}{V_i((k_a)_i - (C_l)_i/V_i)}(e^{(-(k_a)_it_i)}-e^{(-\frac{(C_l)_i}{V_i}t_i)})$$

Where $(k_a)_i$ is the fractional rate of absorption for individual $i$, $(C_l)_i$ is the clearance rate for individual $i$ and $V_i$ is the volume of distribution for individual $i$ and D is the dose injected.
In our notation, the complete model is $p(y_i,\psi_i,\theta_0)$ where $\psi_i = ((k_a)_i, (C_l)_i, V_i)$ is the vector of individual parameters where each component is composed of a fixed effect term and a random effect (a centered Gaussian with same variance $\Omega$) and $\theta_0 = (\Omega_0, \Sigma_0)$ (with $\epsilon_i \sim \mathcal{N}(0,\Sigma_0)$ and $(k_a)_i = (k_a)_{pop} + \eta_{(k_a)_i}$ and $\eta_{(k_a)_i} \sim \mathcal{N}(0,\Omega_0)$).
Our goal is to simulate for instance from the posterior distribution $P((k_a)_i|y_i,\theta_0)$. As we said above we can work on the distribution $P(\eta_{(k_a)_i}|y_i,\theta_0)$ and equivalently for the others parameters.

####Posterior samples for all individuals

```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
#library(rstan)
setwd("/Users/karimimohammedbelhal/Desktop/variationalBayes/mcmc_R_isolate/Dir2")
  source('compute_LL.R') 
  source('func_aux.R') 
  source('func_cov.R') 
  source('func_distcond.R') 
  source('func_FIM.R') 
  source('func_ggplot2.R') 
  source('func_plots.R') 
  source('func_simulations.R') 
  source('ggplot2_global.R') 
  # source('KL.R') 
  #source('vi.R') 
  source('global.R')
  source('main.R')
  source('mcmc_main.R') 
  source('main_estep.R')
  source('main_estep_mcmc.R') 
  source('main_estep_morekernels.R') 
  source('main_initialiseMainAlgo.R') 
  source('main_mstep.R') 
  source('SaemixData.R')
  source('plots_ggplot2.R') 
  source('saemix-package.R') 
  source('SaemixModel.R') 
  source('SaemixRes.R') 
  source('SaemixObject.R') 
  source('zzz.R') 
  
setwd("/Users/karimimohammedbelhal/Documents/GitHub/saem/mala_nest")
source('mala_main.R')
source('main_estep_mala.R')
source("mixtureFunctions.R")

library("mlxR")
library("psych")
library("coda")
library("Matrix")

require(ggplot2)
require(gridExtra)
require(reshape2)

#####################################################################################
# Theophylline

# Data - changing gender to M/F
# theo.saemix<-read.table("data/theo.saemix.tab",header=T,na=".")
# theo.saemix$Sex<-ifelse(theo.saemix$Sex==1,"M","F")
# saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),name.covariates=c("Weight","Sex"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")
iter_mcmc = 600

# Doc
theo.saemix<-read.table( "data/theo.saemix.tab",header=T,na=".")
l <- c(4.02,4.4,4.53,4.4,5.86,4,4.95,4.53,3.1,5.5,4.92,5.3)
for (i in 1:12){
  theo.saemix[(i*10-9):(i*10),'Dose'] = l[i]
}
saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")
# saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt<-function(psi,id,xidep) { 
	dose<-xidep[,1]
	tim<-xidep[,2]  
	ka<-psi[id,1]
	V<-psi[id,2]
	CL<-psi[id,3]
	k<-CL/V
	ypred<-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	return(ypred)
}
# Default model, no covariate
# saemix.model<-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption",psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))
saemix.model<-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption",psi0=matrix(c(10,10,1.05),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))

saemix.options_rwm<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(iter_mcmc,0,0,0,0,0,0))
saemix.options_mala<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,iter_mcmc,0,0,0),sigma.val = 0.01,gamma.val=0.01)
saemix.options_nest<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,0,iter_mcmc,0,0),sigma.val = 0.01,gamma.val=0.01)
saemix.options_amala<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,0,0,iter_mcmc,0),sigma.val = 0.01,gamma.val=0.01)
saemix.options_nonrev<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,0,0,0,iter_mcmc),sigma.val = 0.01,gamma.val=0.01)


post_rwm<-saemix_mala(saemix.model,saemix.data,saemix.options_rwm)$post_rwm
post_mala<-saemix_mala(saemix.model,saemix.data,saemix.options_mala)$post_mala
post_nest<-saemix_mala(saemix.model,saemix.data,saemix.options_mala)$post_mala





final_rwm <- post_rwm[[1]]
for (i in 2:length(post_rwm)) {
  final_rwm <- rbind(final_rwm, post_rwm[[i]])
}


final_mala <- post_mala[[1]]
for (i in 2:length(post_mala)) {
  final_mala <- rbind(final_mala, post_mala[[i]])
}


graphConvMC_twokernels(final_rwm,final_mala, title="RWM vs MALA")
```

####Autocorrelations and MSJD
In terms of Autocorrelation and Mean Square jump distance we get

```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
index=4
rwm.obj <- as.mcmc(post_rwm[[index]])
corr_rwm <- autocorr(rwm.obj[,3])
autocorr.plot(rwm.obj[,3])

mala.obj <- as.mcmc(post_mala[[index]])
corr_mala <- autocorr(mala.obj[,3])
autocorr.plot(mala.obj[,3])


```

```{r}
index=4
print(paste0("msjd rwm: ", mssd(post_rwm[[index]][,3])))
print(paste0("msjd mala: ", mssd(post_mala[[index]][,3])))
```
####Variance of the estimator
20 replicates of RWM and MALA during 1000 iterations
Only the 400 last iterations are used to compare the variances of the estimator

```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
#library(rstan)
setwd("/Users/karimimohammedbelhal/Desktop/variationalBayes/mcmc_R_isolate/Dir2")
  source('compute_LL.R') 
  source('func_aux.R') 
  source('func_cov.R') 
  source('func_distcond.R') 
  source('func_FIM.R') 
  source('func_ggplot2.R') 
  source('func_plots.R') 
  source('func_simulations.R') 
  source('ggplot2_global.R') 
  # source('KL.R') 
  #source('vi.R') 
  source('global.R')
  source('main.R')
  source('mcmc_main.R') 
  source('main_estep.R')
  source('main_estep_mcmc.R') 
  source('main_estep_morekernels.R') 
  source('main_initialiseMainAlgo.R') 
  source('main_mstep.R') 
  source('SaemixData.R')
  source('plots_ggplot2.R') 
  source('saemix-package.R') 
  source('SaemixModel.R') 
  source('SaemixRes.R') 
  source('SaemixObject.R') 
  source('zzz.R') 
  
setwd("/Users/karimimohammedbelhal/Documents/GitHub/saem/mala_nest")
source('mala_main.R')
source('main_estep_mala.R')
source("mixtureFunctions.R")

library("mlxR")
library("psych")
library("coda")
library("Matrix")

require(ggplot2)
require(gridExtra)
require(reshape2)

iter_mcmc = 1000
replicate = 20
seed0 = 39546
indiv=4
burn = 600
# Doc
theo.saemix<-read.table("data/theo.saemix.tab",header=T,na=".")
l <- c(4.02,4.4,4.53,4.4,5.86,4,4.95,4.53,3.1,5.5,4.92,5.3)
for (i in 1:12){
  theo.saemix[(i*10-9):(i*10),'Dose'] = l[i]
}
saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),name.covariates=c("Weight","Sex"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt<-function(psi,id,xidep) { 
	dose<-xidep[,1]
	tim<-xidep[,2]  
	ka<-psi[id,1]
	V<-psi[id,2]
	CL<-psi[id,3]
	k<-CL/V
	ypred<-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	return(ypred)
}

# Default model, no covariate
# saemix.model<-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption",psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))
saemix.model<-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption",psi0=matrix(c(10,10,1.05),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))

final_rwm <- 0
for (j in 1:replicate){
  print(j)
  saemix.options_rwm<-list(seed=j*seed0,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(iter_mcmc,0,0,0,0,0,0))
  post_rwm<-saemix_mala(saemix.model,saemix.data,saemix.options_rwm)$post_rwm
  post_rwm[[indiv]]['individual'] <- j
  final_rwm <- rbind(final_rwm,post_rwm[[indiv]][-1,])
}


names(final_rwm)[1]<-paste("time")
names(final_rwm)[5]<-paste("id")
final_rwm <- final_rwm[c(5,1,2)]
# prctilemlx(final_rwm[-1,],band = list(number = 8, level = 80)) + ylim(-3,-1) + ggtitle("RWM")

#burn
rwm_burn <- final_rwm[final_rwm[,2]>burn,]
#prctilemlx(rwm_burn[-1,-4],band = list(number = 2, level = 80)) + ylim(-3,-1) + ggtitle("RWM")



final_mala <- 0
for (j in 1:replicate){
  print(j)
  saemix.options_mala<-list(seed=j*seed0,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(1,0,0,iter_mcmc,0,0,0),sigma.val=0.01,gamma.val=0.01)
  post_mala<-saemix_mala(saemix.model,saemix.data,saemix.options_mala)$post_mala
  post_mala[[indiv]]['individual'] <- j
  final_mala <- rbind(final_mala,post_mala[[indiv]][-1,])
}


names(final_mala)[1]<-paste("time")
names(final_mala)[5]<-paste("id")
final_mala <- final_mala[c(5,1,2)]
# prctilemlx(final_mala[-1,],band = list(number = 4, level = 80)) + ylim(-3,-1) + ggtitle("MALA")

#burn
mala_burn <- final_mala[final_mala[,2]>burn,]

rwm_burn['group'] <- 1
mala_burn['group'] <- 2
mala_burn$id <- mala_burn$id +1
final <- 0
final <- rbind(rwm_burn,mala_burn)
labels <- c("rwm","mala")
final <- final[c(1,4,2,3)]
prctilemlx(final, band = list(number = 2, level = 80),group='group', label = labels) + theme(legend.position = "none")
```

###Cow (560 individuals 5455 obs)

$$
y_i = y(t_i) = f(\psi_i)+ \epsilon_i
$$
With :

$$f(\psi_i) = a.(1-(b/1000).*exp(-k.*(x/100000)))$$

With $\psi_i = (a_i,b_i,k_i)$


##Nesterov acceleration
Inspired by the Nesterov acceleration of the gradient descent we add a memory term to the Overdamped discretized langevin diffusion

$$X_{k+1} = X_k + \gamma\nabla\log\pi(X) +R(X_{k} - X_{k-1}) + \sqrt{2\gamma}Z$$

Where $R>0$



###Theo case

####Posterior samples for all individuals

####Autocorrelations and MSJD
In terms of Autocorrelation and Mean Square jump distance we get

```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
library("mlxR")
library("psych")
library("coda")
library("Matrix")
index=4
rwm.obj <- as.mcmc(post_rwm[[index]])
corr_rwm <- autocorr(rwm.obj[,3])
autocorr.plot(rwm.obj[,3],main="rwm")

mala.obj <- as.mcmc(post_mala[[index]])
corr_mala <- autocorr(mala.obj[,3])
autocorr.plot(mala.obj[,3],main="mala")


nest.obj <- as.mcmc(post_nest[[index]])
corr_nest <- autocorr(nest.obj[,3])
autocorr.plot(nest.obj[,3],main="nest")

```

```{r}
index=4
print(paste0("msjd rwm: ", mssd(post_rwm[[index]][,3])))
print(paste0("msjd mala: ", mssd(post_mala[[index]][,3])))
print(paste0("msjd nesterov: ", mssd(post_nest[[index]][,3])))
```

####Variance of the estimator
```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
#library(rstan)
setwd("/Users/karimimohammedbelhal/Desktop/variationalBayes/mcmc_R_isolate/Dir2")
  source('compute_LL.R') 
  source('func_aux.R') 
  source('func_cov.R') 
  source('func_distcond.R') 
  source('func_FIM.R') 
  source('func_ggplot2.R') 
  source('func_plots.R') 
  source('func_simulations.R') 
  source('ggplot2_global.R') 
  # source('KL.R') 
  #source('vi.R') 
  source('global.R')
  source('main.R')
  source('mcmc_main.R') 
  source('main_estep.R')
  source('main_estep_mcmc.R') 
  source('main_estep_morekernels.R') 
  source('main_initialiseMainAlgo.R') 
  source('main_mstep.R') 
  source('SaemixData.R')
  source('plots_ggplot2.R') 
  source('saemix-package.R') 
  source('SaemixModel.R') 
  source('SaemixRes.R') 
  source('SaemixObject.R') 
  source('zzz.R') 
  
setwd("/Users/karimimohammedbelhal/Documents/GitHub/saem/mala_nest")
source("mixtureFunctions.R")
source('mala_main.R')
source('main_estep_mala.R')

library("mlxR")
library("psych")
library("coda")
library("Matrix")

require(ggplot2)
require(gridExtra)
require(reshape2)


#####################################################################################
# Theophylline

# Data - changing gender to M/F
# theo.saemix<-read.table("data/theo.saemix.tab",header=T,na=".")
# theo.saemix$Sex<-ifelse(theo.saemix$Sex==1,"M","F")
# saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),name.covariates=c("Weight","Sex"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")
iter_mcmc = 1000
replicate = 10
seed0 = 39546
indiv=4
burn = 600
# Doc
theo.saemix<-read.table("data/theo.saemix.tab",header=T,na=".")
l <- c(4.02,4.4,4.53,4.4,5.86,4,4.95,4.53,3.1,5.5,4.92,5.3)
for (i in 1:12){
  theo.saemix[(i*10-9):(i*10),'Dose'] = l[i]
}
saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),name.covariates=c("Weight","Sex"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt<-function(psi,id,xidep) { 
	dose<-xidep[,1]
	tim<-xidep[,2]  
	ka<-psi[id,1]
	V<-psi[id,2]
	CL<-psi[id,3]
	k<-CL/V
	ypred<-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	return(ypred)
}

# Default model, no covariate
# saemix.model<-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption",psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))
saemix.model<-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption",psi0=matrix(c(10,10,1.05),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))

final_rwm <- 0
for (j in 1:replicate){
  print(j)
  saemix.options_rwm<-list(seed=j*seed0,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(iter_mcmc,0,0,0,0,0,0))
  post_rwm<-saemix_mala(saemix.model,saemix.data,saemix.options_rwm)$post_rwm
  post_rwm[[indiv]]['individual'] <- j
  final_rwm <- rbind(final_rwm,post_rwm[[indiv]][-1,])
}


names(final_rwm)[1]<-paste("time")
names(final_rwm)[5]<-paste("id")
final_rwm <- final_rwm[c(5,1,2)]
# prctilemlx(final_rwm[-1,],band = list(number = 8, level = 80)) + ylim(-3,-1) + ggtitle("RWM")

#burn
rwm_burn <- final_rwm[final_rwm[,2]>burn,]
#prctilemlx(rwm_burn[-1,-4],band = list(number = 2, level = 80)) + ylim(-3,-1) + ggtitle("RWM")



final_mala <- 0
for (j in 1:replicate){
  print(j)
  saemix.options_mala<-list(seed=j*seed0,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(1,0,0,iter_mcmc,0,0,0),sigma.val=0.01,gamma.val=0.01)
  post_mala<-saemix_mala(saemix.model,saemix.data,saemix.options_mala)$post_mala
  post_mala[[indiv]]['individual'] <- j
  final_mala <- rbind(final_mala,post_mala[[indiv]][-1,])
}


names(final_mala)[1]<-paste("time")
names(final_mala)[5]<-paste("id")
final_mala <- final_mala[c(5,1,2)]
# prctilemlx(final_mala[-1,],band = list(number = 4, level = 80)) + ylim(-3,-1) + ggtitle("MALA")

#burn
mala_burn <- final_mala[final_mala[,2]>burn,]
# prctilemlx(mala_burn[-1,-4],band = list(number = 2, level = 80)) + ylim(-3,-1) + ggtitle("MALA")


final_nest <- 0
for (j in 1:replicate){
  print(j)
  saemix.options_nest<-list(seed=j*seed0,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(1,0,0,0,iter_mcmc,0,0),sigma.val=0.01,gamma.val=0.01,memory=0.02)
  post_nest<-saemix_mala(saemix.model,saemix.data,saemix.options_nest)$post_vb
  post_nest[[indiv]]['individual'] <- j
  final_nest <- rbind(final_nest,post_nest[[indiv]][-1,])
}



names(final_nest)[1]<-paste("time")
names(final_nest)[5]<-paste("id")
final_nest <- final_nest[c(5,1,2)]
# prctilemlx(final_nest[-1,],band = list(number = 8, level = 80)) + ylim(-3,-1) + ggtitle("Nesterov")
nest_burn <- final_nest[final_nest[,2]>burn,]

rwm_burn['group'] <- 1
mala_burn['group'] <- 2
mala_burn$id <- mala_burn$id +1
nest_burn['group'] <- 3
nest_burn$id <- nest_burn$id +2

final <- 0

final <- rbind(rwm_burn,mala_burn, nest_burn)


labels <- c("rwm","mala","nest")
final <- final[c(1,4,2,3)]
prctilemlx(final, band = list(number = 2, level = 80),group='group', label = labels) + theme(legend.position = "none")

```

##Anisotropic MALA
In this section we consider the regular langevin diffusion markov chain and set a dependence on the direction of the diffusion for the stepsize for the drift term. The stepsize of the brownian motion, in other words the covariance of the proposal is also dependent of the direction of the gradient.

$$X_{k+1} = X_k + \gamma_1\nabla\log\pi(X)  + \sqrt{2\gamma_2}Z$$

Where:
$$\gamma_1 = \frac{b}{max(b, |\nabla \log \pi|)}$$
Where $b>0$ is a threshold term and:
$$\gamma_2 = \gamma_1^2 \nabla \log \pi^{t} \nabla \log \pi$$

###Theo case

####Posterior samples for all individuals
```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
#library(rstan)
setwd("/Users/karimimohammedbelhal/Desktop/variationalBayes/mcmc_R_isolate/Dir2")
  source('compute_LL.R') 
  source('func_aux.R') 
  source('func_cov.R') 
  source('func_distcond.R') 
  source('func_FIM.R') 
  source('func_ggplot2.R') 
  source('func_plots.R') 
  source('func_simulations.R') 
  source('ggplot2_global.R') 
  # source('KL.R') 
  #source('vi.R') 
  source('global.R')
  source('main.R')
  source('mcmc_main.R') 
  source('main_estep.R')
  source('main_estep_mcmc.R') 
  source('main_estep_morekernels.R') 
  source('main_initialiseMainAlgo.R') 
  source('main_mstep.R') 
  source('SaemixData.R')
  source('plots_ggplot2.R') 
  source('saemix-package.R') 
  source('SaemixModel.R') 
  source('SaemixRes.R') 
  source('SaemixObject.R') 
  source('zzz.R') 
  
setwd("/Users/karimimohammedbelhal/Documents/GitHub/saem/mala_nest")
source('mala_main.R')
source('main_estep_mala.R')
source("mixtureFunctions.R")

library("mlxR")
library("psych")
library("coda")
library("Matrix")

require(ggplot2)
require(gridExtra)
require(reshape2)

#####################################################################################
# Theophylline

# Data - changing gender to M/F
# theo.saemix<-read.table("data/theo.saemix.tab",header=T,na=".")
# theo.saemix$Sex<-ifelse(theo.saemix$Sex==1,"M","F")
# saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),name.covariates=c("Weight","Sex"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")
iter_mcmc = 600

# Doc
theo.saemix<-read.table( "data/theo.saemix.tab",header=T,na=".")
l <- c(4.02,4.4,4.53,4.4,5.86,4,4.95,4.53,3.1,5.5,4.92,5.3)
for (i in 1:12){
  theo.saemix[(i*10-9):(i*10),'Dose'] = l[i]
}
saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")
# saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt<-function(psi,id,xidep) { 
	dose<-xidep[,1]
	tim<-xidep[,2]  
	ka<-psi[id,1]
	V<-psi[id,2]
	CL<-psi[id,3]
	k<-CL/V
	ypred<-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	return(ypred)
}
# Default model, no covariate
# saemix.model<-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption",psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))
saemix.model<-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption",psi0=matrix(c(10,10,1.05),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))


saemix.options_rwm<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(iter_mcmc,0,0,0,0,0,0))
saemix.options_mala<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,iter_mcmc,0,0,0),sigma.val = 0.01,gamma.val=0.01)
saemix.options_nest<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,0,iter_mcmc,0,0),sigma.val = 0.01,gamma.val=0.01,memory=0.02)
saemix.options_amala<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,0,0,iter_mcmc,0),sigma.val = 0.01,gamma.val=0.01)
saemix.options_nonrev<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,0,0,0,iter_mcmc),sigma.val = 0.01,gamma.val=0.01)


post_rwm<-saemix_mala(saemix.model,saemix.data,saemix.options_rwm)$post_rwm
post_mala<-saemix_mala(saemix.model,saemix.data,saemix.options_mala)$post_mala
post_nest<-saemix_mala(saemix.model,saemix.data,saemix.options_nest)$post_vb
post_amala<-saemix_mala(saemix.model,saemix.data,saemix.options_amala)$post_mala


final_rwm <- post_rwm[[1]]
for (i in 2:length(post_rwm)) {
  final_rwm <- rbind(final_rwm, post_rwm[[i]])
}


final_mala <- post_mala[[1]]
for (i in 2:length(post_mala)) {
  final_mala <- rbind(final_mala, post_mala[[i]])
}


final_amala <- post_amala[[1]]
for (i in 2:length(post_amala)) {
  final_amala <- rbind(final_amala, post_amala[[i]])
}

graphConvMC_threekernels(final_rwm,final_mala,final_amala, title="EM")
```

####Autocorrelations and MSJD

In terms of Autocorrelation and Mean Square jump distance we get
```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
index=4

amala.obj <- as.mcmc(post_amala[[index]])
corr_amala <- autocorr(amala.obj[,3])
autocorr.plot(amala.obj[,3],main="amala")
```


```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}

print(paste0("msjd amala: ", mssd(post_amala[[index]][,3])))
```


####Variance of the estimator
```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
```

##Non reversible MALA
Finally, another method is implemented in order to improve autocorrelation and variance properties.
Following R. Poncet Generalized Mala and Neal paper "Non reversible chains are better" (https://arxiv.org/pdf/math/0407281.pdf)

####Posterior samples for all individuals
```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
#library(rstan)
setwd("/Users/karimimohammedbelhal/Desktop/variationalBayes/mcmc_R_isolate/Dir2")
  source('compute_LL.R') 
  source('func_aux.R') 
  source('func_cov.R') 
  source('func_distcond.R') 
  source('func_FIM.R') 
  source('func_ggplot2.R') 
  source('func_plots.R') 
  source('func_simulations.R') 
  source('ggplot2_global.R') 
  # source('KL.R') 
  #source('vi.R') 
  source('global.R')
  source('main.R')
  source('mcmc_main.R') 
  source('main_estep.R')
  source('main_estep_mcmc.R') 
  source('main_estep_morekernels.R') 
  source('main_initialiseMainAlgo.R') 
  source('main_mstep.R') 
  source('SaemixData.R')
  source('plots_ggplot2.R') 
  source('saemix-package.R') 
  source('SaemixModel.R') 
  source('SaemixRes.R') 
  source('SaemixObject.R') 
  source('zzz.R') 
  
setwd("/Users/karimimohammedbelhal/Documents/GitHub/saem/mala_nest")
source('mala_main.R')
source('main_estep_mala.R')
source("mixtureFunctions.R")

library("mlxR")
library("psych")
library("coda")
library("Matrix")

require(ggplot2)
require(gridExtra)
require(reshape2)

#####################################################################################
# Theophylline

# Data - changing gender to M/F
# theo.saemix<-read.table("data/theo.saemix.tab",header=T,na=".")
# theo.saemix$Sex<-ifelse(theo.saemix$Sex==1,"M","F")
# saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),name.covariates=c("Weight","Sex"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")
iter_mcmc = 600

# Doc
theo.saemix<-read.table( "data/theo.saemix.tab",header=T,na=".")
l <- c(4.02,4.4,4.53,4.4,5.86,4,4.95,4.53,3.1,5.5,4.92,5.3)
for (i in 1:12){
  theo.saemix[(i*10-9):(i*10),'Dose'] = l[i]
}
saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")
# saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt<-function(psi,id,xidep) { 
	dose<-xidep[,1]
	tim<-xidep[,2]  
	ka<-psi[id,1]
	V<-psi[id,2]
	CL<-psi[id,3]
	k<-CL/V
	ypred<-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	return(ypred)
}
# Default model, no covariate
# saemix.model<-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption",psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))
saemix.model<-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption",psi0=matrix(c(10,10,1.05),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))

saemix.options_rwm<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(iter_mcmc,0,0,0,0,0,0))
saemix.options_mala<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,iter_mcmc,0,0,0),sigma.val = 0.01,gamma.val=0.01)
saemix.options_nest<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,0,iter_mcmc,0,0),sigma.val = 0.01,gamma.val=0.01,memory=0.02)
saemix.options_amala<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,0,0,iter_mcmc,0),sigma.val = 0.01,gamma.val=0.01)
saemix.options_nonrev<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,0,0,0,iter_mcmc),sigma.val = 0.01,gamma.val=0.01)


post_rwm<-saemix_mala(saemix.model,saemix.data,saemix.options_rwm)$post_rwm
post_mala<-saemix_mala(saemix.model,saemix.data,saemix.options_mala)$post_mala




final_rwm <- post_rwm[[1]]
for (i in 2:length(post_rwm)) {
  final_rwm <- rbind(final_rwm, post_rwm[[i]])
}


final_mala <- post_mala[[1]]
for (i in 2:length(post_mala)) {
  final_mala <- rbind(final_mala, post_mala[[i]])
}

post_nonrev<-saemix_mala(saemix.model,saemix.data,saemix.options_nonrev)$post_mala
final_nonrev <- post_nonrev[[1]]
for (i in 2:length(post_nonrev)) {
  final_nonrev <- rbind(final_nonrev, post_nonrev[[i]])
}
graphConvMC_threekernels(final_rwm,final_mala,final_nonrev, title="EM")
```
####Autocorrelations and MSJD
In terms of Autocorrelation and Mean Square jump distance we get
```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
index=4

nonrev.obj <- as.mcmc(post_nonrev[[index]])
corr_nonrev <- autocorr(nonrev.obj[,3])
autocorr.plot(nonrev.obj[,3])
```


```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
print(paste0("msjd non reversible: ", mssd(post_nonrev[[index]][,3])))
```


####Variance of the estimator
```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
final_nonrev <- 0
for (j in 1:replicate){
  print(j)
  saemix.options_nonrev<-list(seed=j*seed0,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(1,0,0,0,0,0,iter_mcmc),sigma.val=0.01,gamma.val=0.01)
  post_nonrev<-saemix_mala(saemix.model,saemix.data,saemix.options_nonrev)$post_mala
  post_nonrev[[indiv]]['individual'] <- j
  final_nonrev <- rbind(final_nonrev,post_nonrev[[indiv]][-1,])
}


names(final_nonrev)[1]<-paste("time")
names(final_nonrev)[5]<-paste("id")
final_nonrev <- final_nonrev[c(5,1,2)]
# prctilemlx(final_nonrev[-1,],band = list(number = 8, level = 80)) + ylim(-3,-1) + ggtitle("Non reversible")



#burn
nonrev_burn <- final_nonrev[final_nonrev[,2]>burn,]
rwm_burn['group'] <- 1
mala_burn['group'] <- 2
mala_burn$id <- mala_burn$id +1
nonrev_burn['group'] <- 3
nonrev_burn$id <- nonrev_burn$id +3

final <- 0
final <- rbind(rwm_burn,mala_burn, nonrev_burn)


labels <- c("rwm","mala","nonrev")
final <- final[c(1,4,2,3)]
prctilemlx(final, band = list(number = 2, level = 80),group='group', label = labels) + theme(legend.position = "none")

```

#Moreau Yosida MALA (MAMYULA)

In all of our cases the potential is composed of a smooth and a non smooth part.


####Theo case
```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
#library(rstan)
setwd("/Users/karimimohammedbelhal/Desktop/variationalBayes/mcmc_R_isolate/Dir2")
  source('compute_LL.R') 
  source('func_aux.R') 
  source('func_cov.R') 
  source('func_distcond.R') 
  source('func_FIM.R') 
  source('func_ggplot2.R') 
  source('func_plots.R') 
  source('func_simulations.R') 
  source('ggplot2_global.R') 
  # source('KL.R') 
  #source('vi.R') 
  source('global.R')
  source('main.R')
  source('mcmc_main.R') 
  source('main_estep.R')
  source('main_estep_mcmc.R') 
  source('main_estep_morekernels.R') 
  source('main_initialiseMainAlgo.R') 
  source('main_mstep.R') 
  source('SaemixData.R')
  source('plots_ggplot2.R') 
  source('saemix-package.R') 
  source('SaemixModel.R') 
  source('SaemixRes.R') 
  source('SaemixObject.R') 
  source('zzz.R') 
  
setwd("/Users/karimimohammedbelhal/Documents/GitHub/saem/mamyula")
source('mala_main.R')
source('main_estep_mala.R')
source("mixtureFunctions.R")

library("mlxR")
library("psych")
library("coda")
library("Matrix")

require(ggplot2)
require(gridExtra)
require(reshape2)

#####################################################################################
# Theophylline

# Data - changing gender to M/F
# theo.saemix<-read.table("data/theo.saemix.tab",header=T,na=".")
# theo.saemix$Sex<-ifelse(theo.saemix$Sex==1,"M","F")
# saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),name.covariates=c("Weight","Sex"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")
iter_mcmc = 200

# Doc
theo.saemix<-read.table( "data/theo.saemix.tab",header=T,na=".")
l <- c(4.02,4.4,4.53,4.4,5.86,4,4.95,4.53,3.1,5.5,4.92,5.3)
for (i in 1:12){
  theo.saemix[(i*10-9):(i*10),'Dose'] = l[i]
}
saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")
# saemix.data<-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, name.group=c("Id"),name.predictors=c("Dose","Time"),name.response=c("Concentration"),units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt<-function(psi,id,xidep) { 
  dose<-xidep[,1]
  tim<-xidep[,2]  
  ka<-psi[id,1]
  V<-psi[id,2]
  CL<-psi[id,3]
  k<-CL/V
  ypred<-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
  return(ypred)
}
# Default model, no covariate
# saemix.model<-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption",psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))
saemix.model<-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption",psi0=matrix(c(10,10,1.05),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))

saemix.options_rwm<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(iter_mcmc,0,0,0,0,0))
saemix.options_mala<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,iter_mcmc,0,0),sigma.val = 0.01,gamma.val = 0.01)
saemix.options_mamyula<-list(seed=39546,map=F,fim=F,ll.is=F, nb.chains = 1, nbiter.mcmc = c(0,0,0,0,iter_mcmc,0),sigma.val = 0.1,gamma.val = 0.01)


post_rwm<-saemix_mala(saemix.model,saemix.data,saemix.options_rwm)$post_rwm
post_mala<-saemix_mala(saemix.model,saemix.data,saemix.options_mala)$post_mala
post_mamyula<-saemix_mala(saemix.model,saemix.data,saemix.options_mamyula)$post_mala

index = 4
graphConvMC_threekernels(post_rwm[[index]],post_mala[[index]],post_mamyula[[index]], title="EM")

```


####Posterior samples for all individuals
```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
final_rwm <- post_rwm[[1]]
for (i in 2:length(post_rwm)) {
  final_rwm <- rbind(final_rwm, post_rwm[[i]])
}


final_mala <- post_mala[[1]]
for (i in 2:length(post_mala)) {
  final_mala <- rbind(final_mala, post_mala[[i]])
}

final_mamyula <- post_mamyula[[1]]
for (i in 2:length(post_mamyula)) {
  final_mamyula <- rbind(final_mamyula, post_mamyula[[i]])
}



graphConvMC_threekernels(final_rwm,final_mala,final_mamyula, title="EM")
```

####Autocorrelations and MSJD
In terms of Autocorrelation and Mean Square jump distance we get
```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
index=4
rwm.obj <- as.mcmc(post_rwm[[index]])
corr_rwm <- autocorr(rwm.obj[,3])
autocorr.plot(rwm.obj[,3],main="rwm")

mala.obj <- as.mcmc(post_mala[[index]])
corr_mala <- autocorr(mala.obj[,3])
autocorr.plot(mala.obj[,3],main="mala")

mamyula.obj <- as.mcmc(post_mamyula[[index]])
corr_mamyula <- autocorr(mamyula.obj[,3])
autocorr.plot(mamyula.obj[,3],main="mamyula")

```


```{r,echo=FALSE,cache=FALSE, results=FALSE, warning=FALSE, comment=FALSE, warning=FALSE,message=FALSE}
print(paste0("msjd rwm: ", mssd(post_rwm[[index]][,3])))
print(paste0("msjd mala: ", mssd(post_mala[[index]][,3])))
print(paste0("msjd mamyula: ", mssd(post_mamyula[[index]][,3])))
```



#SAEM with MALA and MAMYULA

##Theo case 

####Variance of the estimator
<img src="/Users/karimimohammedbelhal/Documents/GitHub/saem/mamyula/pics/file5.pdf" alt="Drawing" style="width: 1000px;"/>


##Cow case
####Variance of the estimator
<img src="/Users/karimimohammedbelhal/Documents/GitHub/saem/mamyula/pics/file5.pdf" alt="Drawing" style="width: 1000px;"/>


