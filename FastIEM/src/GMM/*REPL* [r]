
R version 3.3.2 (2016-10-31) -- "Sincere Pumpkin Patch"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.4.0 (64-bit)

R est un logiciel libre livr'e sans AUCUNE GARANTIE.
Vous pouvez le redistribuer sous certaines conditions.
Tapez 'license()' ou 'licence()' pour plus de d'etails.

R est un projet collaboratif avec de nombreux contributeurs.
Tapez 'contributors()' pour plus d'information et
'citation()' pour la facon de le citer dans les publications.

Tapez 'demo()' pour des d'emonstrations, 'help()' pour l'aide
en ligne ou 'help.start()' pour obtenir l'aide au format HTML.
Tapez 'q()' pour quitter R.

> source("algos.R")
Le chargement a n'ecessit'e le package : ggplot2
Le chargement a n'ecessit'e le package : gridExtra
Le chargement a n'ecessit'e le package : reshape2
> source("func.R")
> source("plots.R")
> theme_set(theme_bw())
> options(digits = 22)
> # save.image("gmm_mu.RData")
> # save.image("gmm_mu2.RData")
> # save.image("gmm_mu3.RData")
> # load("gmm_mu.RData")
> n <- 100
> weight<-c(0.2, 0.8) 
> mu<-c(-1,1)
> sigma<-c(1,1)*1
> 
> 
> weight0<-weight
> mu0<-c(-2,2)
> sigma0<-sigma
> 
> 
> K <- 2000
> 
> seed0=44444
> 
> 
> # ylim <- c(0.15, 0.5, 0.4)
> ylim <- c(0.3)
> 
> M <- 1
> nsim <- 3
> #
> G<-length(mu)
> col.names <- c("iteration", paste0("p",1:G), paste0("mu",1:G), paste0("sigm<", paste0("p",1:G), paste0("mu",1:G), paste0("sigma                        ",1:G))
> theta<-list(p=weight,mu=mu,sigma=sigma)
> theta0<-list(p=weight0,mu=mu0,sigma=sigma0)
> # theta0<-theta
> 
> 
> ##  Simulation
> x <- matrix(0,nrow=n,ncol=nsim)
> for (j in (1:nsim))
+ {
+   seed <- j*seed0
+   set.seed(seed)
+   xj<-mixt.simulate(n,weight,mu,sigma)
+   x[,j] <- xj
+ }
> 
> 
> a1 = c(rep(theta$p[1],(K+1)))
> a2 = c(rep(theta$p[2],(K+1)))
> b1 = c(rep(theta$mu[1],(K+1)))
> b2 = c(rep(theta$mu[2],(K+1)))
> d1 = c(rep(theta$sigma[1],(K+1)))
> d2 = c(rep(theta$sigma[2],(K+1)))
> 
> ML <- cbind(1:(K+1),a1,a2,b1,b2,d1,d2)
> 
> print('EM')
[1] "EM"
> dem <- NULL
> 
> df.em <- vector("list", length=nsim)
> Kem <- K/n
> 
> nbr<-1
> diem <- NULL
> df.iem <- vector("list", length=nsim)
> 
> doem <- NULL
> df.oem <- vector("list", length=nsim)
> 
> doemvr <- NULL
> df.oemvr <- vector("list", length=nsim)
> 
> rho.oemvr <- 0.5
> kiter = 1:K
> rho.oem = 3/(kiter+10)
> 
> for (j in (1:nsim))
+ {
+   print(j)
+   seed <- j*seed0
+   set.seed(seed)
+   x <- matrix(0,nrow=n,ncol=nsim)
+   xj<-mixt.simulate(n,weight,mu,sigma)
+   x[,j] <- xj
+ 
+   df <- mixt.em(x[,j], theta0, Kem)
+   # ML <- df
+   # ML[1:(K+1),2:7]<- df[(K+1),2:7]
+   df[,2:7] <- (df[,2:7] - ML[1:(Kem+1),2:7])^2
+   df$rep <- j
+   dem <- rbind(dem,df)
+   df$rep <- NULL
+   df.em[[j]] <- df
+ 
+   df <- mixt.iem(x[,j], theta0, K,nbr)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   diem <- rbind(diem,df)
+   df$rep <- NULL
+   df.iem[[j]] <- df
+ 
+   df <- mixt.oem(x[,j], theta0, K,nbr,rho.oem)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   doem <- rbind(doem,df)
+   df$rep <- NULL
+   df.oem[[j]] <- df
+ 
+   df <- mixt.oemvr(x[,j], theta0, K,nbr,rho.oemvr)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   doemvr <- rbind(doemvr,df)
+   df$rep <- NULL
+   df.oemvr[[j]] <- df
+ }
[1] 1
[1] 2
[1] 3
> 
> 
> 
> # dem[,2:7] <- dem[,2:7]^2
> em <- NULL
> em <- dem[dem$rep==1,]
> 
> if (nsim>2) {
+    for (j in (2:nsim))
+ {
+   em[,2:7] <- em[,2:7]+dem[dem$rep==j,2:7]
+ }
+ }
> em[,2:7] <- 1/nsim*em[,2:7]
> em[,9]<-NULL
> 
> 
> 
> iem <- NULL
> iem <- diem[diem$rep==1,]
> 
> if (nsim>2) {
+ for (j in (2:nsim))
+ {
+   iem[,2:7] <- iem[,2:7]+diem[diem$rep==j,2:7]
+ }
+ }
> 
> iem[,2:7] <- 1/nsim*iem[,2:7]
> iem[,9]<-NULL
> 
> 
> 
> oem <- NULL
> oem <- doem[doem$rep==1,]
> 
> if (nsim>2) {
+     for (j in (2:nsim))
+   {
+     oem[,2:7] <- oem[,2:7]+doem[doem$rep==j,2:7]
+   }
+ }
> 
> oem[,2:7] <- 1/nsim*oem[,2:7]
> oem[,9]<-NULL
> 
> 
> 
> 
> # doemvr <- NULL
> # df.oemvr <- vector("list", length=nsim)
> # rho <- 0.001
> # for (j in (1:nsim))
> # {
> #   print(j)
> #   df <- mixt.oemvr(x[,j], theta0, K,nbr, rho)
> #   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
> #   df$rep <- j
> #   doemvr <- rbind(doemvr,df)
> #   df$rep <- NULL
> #   df.oemvr[[j]] <- df
> # }
> 
> 
> oemvr <- NULL
> oemvr <- doemvr[doemvr$rep==1,]
> 
> if (nsim>2) {
+     for (j in (2:nsim))
+   {
+     oemvr[,2:7] <- oemvr[,2:7]+doemvr[doemvr$rep==j,2:7]
+   }
+ }
> 
> oemvr[,2:7] <- 1/nsim*oemvr[,2:7]
> oemvr[,9]<-NULL
> 
> # oemvr$algo <- 'OEMvr'
> # oemvr$rep <- NULL
> # variance <- NULL
> # variance <- rbind(oemvr[1:(K+1),c(1,5,8)],iem[1:(K+1),c(1,5,8)],oem[1:(K+<[1:(K+1),c(1,5,8)],iem[1:(K+1),c(1,5,8)],oem[1:(K+1                        ),c(1,5,8)],em_scaled[1:(<K+1),c(1,5,8)],oem[1:(K+1),c(1,5,8)],em_scaled[1:(K                        +1),c(1,5,8)])
> # graphConvMC2_new(variance, title="IEMs",legend=TRUE)
> 
> 
> iem$algo <- 'IEM'
> oem$algo <- 'OEM'
> oemvr$algo <- 'OEMvr'
> em$algo <- 'EM'
> 
> em$rep <- NULL
> iem$rep <- NULL
> oem$rep <- NULL
> oemvr$rep <- NULL
> 
> 
> # variance <- NULL
> # # variance <- rbind(oemvr[1001:2001,c(1,5,8)],iem[1001:2001,c(1,5,8)],oem<vr[1001:2001,c(1,5,8)],iem[1001:2001,c(1,5,8)],oem[                        1001:2001,c(1,5,8)],em_sc<[1001:2001,c(1,5,8)],oem[1001:2001,c(1,5,8)],em_sca                        led[1001:2001,c(1,5,8)])
> # variance <- rbind(oemvr[2:(K+1),c(1,5,8)],iem[2:(K+1),c(1,5,8)],oem[2:(K+<[2:(K+1),c(1,5,8)],iem[2:(K+1),c(1,5,8)],oem[2:(K+1                        ),c(1,5,8)],em_scaled[2:(<K+1),c(1,5,8)],oem[2:(K+1),c(1,5,8)],em_scaled[2:(K                        +1),c(1,5,8)])
> # graphConvMC2_new(variance, title="IEMs",legend=TRUE)
> 
> ### PER EPOCH
> epochs = seq(1, K, by=n)
> em_ep <- em[1:(K/n),]
> em_ep$iteration <- 1:(K/n)
> iem_ep <- iem[epochs,]
> iem_ep$iteration <- 1:(K/n)
> oem_ep <- oem[epochs,]
> oem_ep$iteration <- 1:(K/n)
> oemvr_ep <- oemvr[epochs,]
> oemvr_ep$iteration <- 1:(K/n)
> 
> # variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
> #                   oem_ep[2:20,c(1,5,8)],em_scaled_ep[2:20,c(1,5,8)])
> 
> variance <- rbind(oemvr_ep[,c(1,5,8)],iem_ep[,c(1,5,8)],
+                   oem_ep[,c(1,5,8)],em_ep[,c(1,5,8)])
> variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
+                   oem_ep[2:20,c(1,5,8)],em_ep[2:20,c(1,5,8)])
> variance <- rbind(iem_ep[10:20,c(1,5,8)],em_ep[10:20,c(1,5,8)])
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> 
> variance <- rbind(iem_ep[10:20,c(1,5,8)],oemvr_ep[10:20,c(1,5,8)])
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
+                   oem_ep[2:20,c(1,5,8)],em_ep[2:20,c(1,5,8)])
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> variance <- rbind(oemvr_ep[,c(1,5,8)],iem_ep[,c(1,5,8)],
+                   oem_ep[,c(1,5,8)],em_ep[,c(1,5,8)])
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
+                   oem_ep[2:20,c(1,5,8)],em_ep[2:20,c(1,5,8)])
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> variance <- rbind(oemvr_ep[5:20,c(1,5,8)],iem_ep[5:20,c(1,5,8)],
+                   oem_ep[5:20,c(1,5,8)],em_ep[5:20,c(1,5,8)])
> # variance <- rbind(iem_ep[10:20,c(1,5,8)],em_ep[10:20,c(1,5,8)])
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> require(ggplot2)
> require(gridExtra)
> require(reshape2)
> 
> 
> mixt.ident <- function(df)
+ {
+   G <- (ncol(df)-1)/3
+   K <- nrow(df)
+   mu.final <- as.numeric(as.character(df[K,(G+2):(2*G+1)]))
+   ind <- sort.int(mu.final, index.return=TRUE)$ix
+   df[,2:(G+1)] <- df[,(G-1+ind)]
+   df[,(G+2):(2*G+1)] <- df[,(2*G-1+ind)]
+   df[,(2*G+2):(3*G+1)] <- df[,(3*G-1+ind)]
+   return(df)
+ }
> 
> mixt.ident3 <- function(df)
+ {
+   G <- (ncol(df)-1)/3
+   K <- nrow(df)
+   mu.final <- as.numeric(as.character(df[K,(G+2):(2*G+1)]))
+   ind <- sort.int(mu.final, index.return=TRUE)$ix
+   df[,2:(G+1)] <- df[,(G-2+ind)]
+   df[,(G+2):(2*G+1)] <- df[,(2*G-2+ind)]
+   df[,(2*G+2):(3*G+1)] <- df[,(3*G-2+ind)]
+   return(df)
+ }
> 
> 
> 
> graphConvMC_new <- function(df, title=NULL, ylim=NULL)
+ {
+   G <- (ncol(df)-2)/3
+   df$rep <- as.factor(df$rep)
+   ylim <-rep(ylim,each=2)
+   graf <- vector("list", ncol(df)-2)
+   o <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
+   for (j in (2:(ncol(df)-1)))
+   {
+     grafj <- ggplot(df)+geom_line(aes_string(df[,1],df[,j],by=df[,ncol(df)]<eom_line(aes_string(df[,1],df[,j],by=df[,ncol(df)])                        ) +
+       xlab("iteration") + ylab(names(df[j])) 
+     if (!is.null(ylim))
+       grafj <- grafj + ylim(ylim[j-1]*c(-1,1))
+     graf[[o[j]]] <- grafj
+   }
+   do.call("grid.arrange", c(graf, ncol=3, top=title))
+ }
> 
> 
> graphConvMC2_new <- function(df, title=NULL, ylim=NULL, legend=TRUE)
+ {
+   G <- (ncol(df)-2)/3
+   df$algo <- as.factor(df$algo)
+   ylim <-rep(ylim,each=2)
+   graf <- vector("list", ncol(df)-2)
+   o <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
+   for (j in (2:(ncol(df)-1)))
+   {
+     grafj <- ggplot(df,aes(colour=df$algo ))+geom_line(aes_string(df[,1],df<s(colour=df$algo ))+geom_line(aes_string(df[,1],df[                        ,j],by=df[,ncol(df)]),sho<ine(aes_string(df[,1],df[,j],by=df[,ncol(df)]),show                        .legend = legend) +
+       xlab("iteration") +  ylab(names(df[j])) 
+     if (!is.null(ylim))
+       grafj <- grafj + ylim(ylim[j-1]*c(-1,1))
+     graf[[o[j]]] <- grafj
+   }
+   do.call("grid.arrange", c(graf, ncol=1, top=title))
+ }
> 
> 
> 
> graphConvMC <- function(df,df2,df3,df4, title=NULL, ylim=NULL)
+ {
+   G <- (ncol(df)-2)/3
+   df$algo <- as.factor(df$algo)
+   df2$algo <- as.factor(df2$algo)
+   df3$algo <- as.factor(df3$algo)
+   df4$algo <- as.factor(df4$algo)
+   ylim <-rep(ylim,each=2)
+   graf <- vector("list", ncol(df)-2)
+   o <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
+   for (j in (2:(ncol(df)-1)))
+   {
+     grafj <- ggplot(df)+geom_line(aes_string(df[,1],df[,j],by=df[,ncol(df)]<eom_line(aes_string(df[,1],df[,j],by=df[,ncol(df)])                        ,colour="black",linetype=<,df[,j],by=df[,ncol(df)]),colour="black",linetype=                         "solid",size=2)+
+     geom_line(aes_string(df2[,1],df2[,j],by=df2[,ncol(df2)]),colour="black"<df2[,1],df2[,j],by=df2[,ncol(df2)]),colour="black",                        linetype="longdash",size=<ol(df2)]),colour="black",linetype="longdash",size=2                        )+
+     geom_line(aes_string(df3[,1],df3[,j],by=df3[,ncol(df3)]),colour="red",l<df3[,1],df3[,j],by=df3[,ncol(df3)]),colour="red",li                        netype="dotted",size=2)+
+     geom_line(aes_string(df4[,1],df4[,j],by=df4[,ncol(df4)]),colour="blue",<df4[,1],df4[,j],by=df4[,ncol(df4)]),colour="blue",l                        inetype="dotted",size=2)+
+       xlab("") +ylab(expression(paste(beta,"1")))  + theme_bw() + theme(pan<ession(paste(beta,"1")))  + theme_bw() + theme(pane                        l.border = element_blank(<+ theme_bw() + theme(panel.border = element_blank()                        , panel.grid.major = elem<.border = element_blank(), panel.grid.major = eleme                        nt_blank(),
+ panel.grid.minor = element_blank(), axis.line = element_line(colour = "blac<t_blank(), axis.line = element_line(colour = "black                        "),axis.text.x = element_<ment_line(colour = "black"),axis.text.x = element_t                        ext(face="bold", color="b<),axis.text.x = element_text(face="bold", color="bl                        ack", 
+                            size=30, angle=0),
+           axis.text.y = element_text(face="bold", color="black", 
+                            size=30, angle=0))+theme(axis.title = element_te<  size=30, angle=0))+theme(axis.title = element_tex                        t(color="black", face="bo<(axis.title = element_text(color="black", face="bol                        d", size=30)) 
+     if (!is.null(ylim))
+       grafj <- grafj + ylim(ylim[j-1]*c(-1,1))
+     graf[[o[j]]] <- grafj
+ 
+   }
+   do.call("grid.arrange", c(graf, ncol=1, top=title))
+ }
> 
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> 
> print('EM')
[1] "EM"
> dem <- NULL
> 
> df.em <- vector("list", length=nsim)
> Kem <- K/n
> 
> nbr<-1
> diem <- NULL
> df.iem <- vector("list", length=nsim)
> 
> doem <- NULL
> df.oem <- vector("list", length=nsim)
> 
> doemvr <- NULL
> df.oemvr <- vector("list", length=nsim)
> 
> rho.oemvr <- 0.05
> kiter = 1:K
> rho.oem = 3/(kiter+10)
> 
> for (j in (1:nsim))
+ {
+   print(j)
+   seed <- j*seed0
+   set.seed(seed)
+   x <- matrix(0,nrow=n,ncol=nsim)
+   xj<-mixt.simulate(n,weight,mu,sigma)
+   x[,j] <- xj
+ 
+   df <- mixt.em(x[,j], theta0, Kem)
+   # ML <- df
+   # ML[1:(K+1),2:7]<- df[(K+1),2:7]
+   df[,2:7] <- (df[,2:7] - ML[1:(Kem+1),2:7])^2
+   df$rep <- j
+   dem <- rbind(dem,df)
+   df$rep <- NULL
+   df.em[[j]] <- df
+ 
+   df <- mixt.iem(x[,j], theta0, K,nbr)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   diem <- rbind(diem,df)
+   df$rep <- NULL
+   df.iem[[j]] <- df
+ 
+   df <- mixt.oem(x[,j], theta0, K,nbr,rho.oem)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   doem <- rbind(doem,df)
+   df$rep <- NULL
+   df.oem[[j]] <- df
+ 
+   df <- mixt.oemvr(x[,j], theta0, K,nbr,rho.oemvr)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   doemvr <- rbind(doemvr,df)
+   df$rep <- NULL
+   df.oemvr[[j]] <- df
+ }
[1] 1
[1] 2
[1] 3
> 
> 
> 
> # dem[,2:7] <- dem[,2:7]^2
> em <- NULL
> em <- dem[dem$rep==1,]
> 
> if (nsim>2) {
+    for (j in (2:nsim))
+ {
+   em[,2:7] <- em[,2:7]+dem[dem$rep==j,2:7]
+ }
+ }
> em[,2:7] <- 1/nsim*em[,2:7]
> em[,9]<-NULL
> 
> 
> 
> iem <- NULL
> iem <- diem[diem$rep==1,]
> 
> if (nsim>2) {
+ for (j in (2:nsim))
+ {
+   iem[,2:7] <- iem[,2:7]+diem[diem$rep==j,2:7]
+ }
+ }
> 
> iem[,2:7] <- 1/nsim*iem[,2:7]
> iem[,9]<-NULL
> 
> 
> 
> oem <- NULL
> oem <- doem[doem$rep==1,]
> 
> if (nsim>2) {
+     for (j in (2:nsim))
+   {
+     oem[,2:7] <- oem[,2:7]+doem[doem$rep==j,2:7]
+   }
+ }
> 
> oem[,2:7] <- 1/nsim*oem[,2:7]
> oem[,9]<-NULL
> 
> 
> 
> 
> # doemvr <- NULL
> # df.oemvr <- vector("list", length=nsim)
> # rho <- 0.001
> # for (j in (1:nsim))
> # {
> #   print(j)
> #   df <- mixt.oemvr(x[,j], theta0, K,nbr, rho)
> #   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
> #   df$rep <- j
> #   doemvr <- rbind(doemvr,df)
> #   df$rep <- NULL
> #   df.oemvr[[j]] <- df
> # }
> 
> 
> oemvr <- NULL
> oemvr <- doemvr[doemvr$rep==1,]
> 
> if (nsim>2) {
+     for (j in (2:nsim))
+   {
+     oemvr[,2:7] <- oemvr[,2:7]+doemvr[doemvr$rep==j,2:7]
+   }
+ }
> 
> oemvr[,2:7] <- 1/nsim*oemvr[,2:7]
> oemvr[,9]<-NULL
> 
> # oemvr$algo <- 'OEMvr'
> # oemvr$rep <- NULL
> # variance <- NULL
> # variance <- rbind(oemvr[1:(K+1),c(1,5,8)],iem[1:(K+1),c(1,5,8)],oem[1:(K+<[1:(K+1),c(1,5,8)],iem[1:(K+1),c(1,5,8)],oem[1:(K+1                        ),c(1,5,8)],em_scaled[1:(<K+1),c(1,5,8)],oem[1:(K+1),c(1,5,8)],em_scaled[1:(K                        +1),c(1,5,8)])
> # graphConvMC2_new(variance, title="IEMs",legend=TRUE)
> 
> 
> iem$algo <- 'IEM'
> oem$algo <- 'OEM'
> oemvr$algo <- 'OEMvr'
> em$algo <- 'EM'
> 
> em$rep <- NULL
> iem$rep <- NULL
> oem$rep <- NULL
> oemvr$rep <- NULL
> 
> 
> # variance <- NULL
> # # variance <- rbind(oemvr[1001:2001,c(1,5,8)],iem[1001:2001,c(1,5,8)],oem<vr[1001:2001,c(1,5,8)],iem[1001:2001,c(1,5,8)],oem[                        1001:2001,c(1,5,8)],em_sc<[1001:2001,c(1,5,8)],oem[1001:2001,c(1,5,8)],em_sca                        led[1001:2001,c(1,5,8)])
> # variance <- rbind(oemvr[2:(K+1),c(1,5,8)],iem[2:(K+1),c(1,5,8)],oem[2:(K+<[2:(K+1),c(1,5,8)],iem[2:(K+1),c(1,5,8)],oem[2:(K+1                        ),c(1,5,8)],em_scaled[2:(<K+1),c(1,5,8)],oem[2:(K+1),c(1,5,8)],em_scaled[2:(K                        +1),c(1,5,8)])
> # graphConvMC2_new(variance, title="IEMs",legend=TRUE)
> 
> ### PER EPOCH
> epochs = seq(1, K, by=n)
> em_ep <- em[1:(K/n),]
> em_ep$iteration <- 1:(K/n)
> iem_ep <- iem[epochs,]
> iem_ep$iteration <- 1:(K/n)
> oem_ep <- oem[epochs,]
> oem_ep$iteration <- 1:(K/n)
> oemvr_ep <- oemvr[epochs,]
> oemvr_ep$iteration <- 1:(K/n)
> 
> # variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
> #                   oem_ep[2:20,c(1,5,8)],em_scaled_ep[2:20,c(1,5,8)])
> 
> variance <- rbind(oemvr_ep[,c(1,5,8)],iem_ep[,c(1,5,8)],
+                   oem_ep[,c(1,5,8)],em_ep[,c(1,5,8)])
> variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
+                   oem_ep[2:20,c(1,5,8)],em_ep[2:20,c(1,5,8)])
> variance <- rbind(oemvr_ep[5:20,c(1,5,8)],iem_ep[5:20,c(1,5,8)],
+                   oem_ep[5:20,c(1,5,8)],em_ep[5:20,c(1,5,8)])
> # variance <- rbind(iem_ep[10:20,c(1,5,8)],em_ep[10:20,c(1,5,8)])
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> print('EM')
[1] "EM"
> dem <- NULL
> 
> df.em <- vector("list", length=nsim)
> Kem <- K/n
> 
> nbr<-1
> diem <- NULL
> df.iem <- vector("list", length=nsim)
> 
> doem <- NULL
> df.oem <- vector("list", length=nsim)
> 
> doemvr <- NULL
> df.oemvr <- vector("list", length=nsim)
> 
> rho.oemvr <- 0.005
> kiter = 1:K
> rho.oem = 3/(kiter+10)
> 
> for (j in (1:nsim))
+ {
+   print(j)
+   seed <- j*seed0
+   set.seed(seed)
+   x <- matrix(0,nrow=n,ncol=nsim)
+   xj<-mixt.simulate(n,weight,mu,sigma)
+   x[,j] <- xj
+ 
+   df <- mixt.em(x[,j], theta0, Kem)
+   # ML <- df
+   # ML[1:(K+1),2:7]<- df[(K+1),2:7]
+   df[,2:7] <- (df[,2:7] - ML[1:(Kem+1),2:7])^2
+   df$rep <- j
+   dem <- rbind(dem,df)
+   df$rep <- NULL
+   df.em[[j]] <- df
+ 
+   df <- mixt.iem(x[,j], theta0, K,nbr)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   diem <- rbind(diem,df)
+   df$rep <- NULL
+   df.iem[[j]] <- df
+ 
+   df <- mixt.oem(x[,j], theta0, K,nbr,rho.oem)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   doem <- rbind(doem,df)
+   df$rep <- NULL
+   df.oem[[j]] <- df
+ 
+   df <- mixt.oemvr(x[,j], theta0, K,nbr,rho.oemvr)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   doemvr <- rbind(doemvr,df)
+   df$rep <- NULL
+   df.oemvr[[j]] <- df
+ }
[1] 1
[1] 2
[1] 3
> 
> 
> 
> # dem[,2:7] <- dem[,2:7]^2
> em <- NULL
> em <- dem[dem$rep==1,]
> 
> if (nsim>2) {
+    for (j in (2:nsim))
+ {
+   em[,2:7] <- em[,2:7]+dem[dem$rep==j,2:7]
+ }
+ }
> em[,2:7] <- 1/nsim*em[,2:7]
> em[,9]<-NULL
> 
> 
> 
> iem <- NULL
> iem <- diem[diem$rep==1,]
> 
> if (nsim>2) {
+ for (j in (2:nsim))
+ {
+   iem[,2:7] <- iem[,2:7]+diem[diem$rep==j,2:7]
+ }
+ }
> 
> iem[,2:7] <- 1/nsim*iem[,2:7]
> iem[,9]<-NULL
> 
> 
> 
> oem <- NULL
> oem <- doem[doem$rep==1,]
> 
> if (nsim>2) {
+     for (j in (2:nsim))
+   {
+     oem[,2:7] <- oem[,2:7]+doem[doem$rep==j,2:7]
+   }
+ }
> 
> oem[,2:7] <- 1/nsim*oem[,2:7]
> oem[,9]<-NULL
> 
> 
> 
> 
> # doemvr <- NULL
> # df.oemvr <- vector("list", length=nsim)
> # rho <- 0.001
> # for (j in (1:nsim))
> # {
> #   print(j)
> #   df <- mixt.oemvr(x[,j], theta0, K,nbr, rho)
> #   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
> #   df$rep <- j
> #   doemvr <- rbind(doemvr,df)
> #   df$rep <- NULL
> #   df.oemvr[[j]] <- df
> # }
> 
> 
> oemvr <- NULL
> oemvr <- doemvr[doemvr$rep==1,]
> 
> if (nsim>2) {
+     for (j in (2:nsim))
+   {
+     oemvr[,2:7] <- oemvr[,2:7]+doemvr[doemvr$rep==j,2:7]
+   }
+ }
> 
> oemvr[,2:7] <- 1/nsim*oemvr[,2:7]
> oemvr[,9]<-NULL
> 
> # oemvr$algo <- 'OEMvr'
> # oemvr$rep <- NULL
> # variance <- NULL
> # variance <- rbind(oemvr[1:(K+1),c(1,5,8)],iem[1:(K+1),c(1,5,8)],oem[1:(K+<[1:(K+1),c(1,5,8)],iem[1:(K+1),c(1,5,8)],oem[1:(K+1                        ),c(1,5,8)],em_scaled[1:(<K+1),c(1,5,8)],oem[1:(K+1),c(1,5,8)],em_scaled[1:(K                        +1),c(1,5,8)])
> # graphConvMC2_new(variance, title="IEMs",legend=TRUE)
> 
> 
> iem$algo <- 'IEM'
> oem$algo <- 'OEM'
> oemvr$algo <- 'OEMvr'
> em$algo <- 'EM'
> 
> em$rep <- NULL
> iem$rep <- NULL
> oem$rep <- NULL
> oemvr$rep <- NULL
> 
> 
> # variance <- NULL
> # # variance <- rbind(oemvr[1001:2001,c(1,5,8)],iem[1001:2001,c(1,5,8)],oem<vr[1001:2001,c(1,5,8)],iem[1001:2001,c(1,5,8)],oem[                        1001:2001,c(1,5,8)],em_sc<[1001:2001,c(1,5,8)],oem[1001:2001,c(1,5,8)],em_sca                        led[1001:2001,c(1,5,8)])
> # variance <- rbind(oemvr[2:(K+1),c(1,5,8)],iem[2:(K+1),c(1,5,8)],oem[2:(K+<[2:(K+1),c(1,5,8)],iem[2:(K+1),c(1,5,8)],oem[2:(K+1                        ),c(1,5,8)],em_scaled[2:(<K+1),c(1,5,8)],oem[2:(K+1),c(1,5,8)],em_scaled[2:(K                        +1),c(1,5,8)])
> # graphConvMC2_new(variance, title="IEMs",legend=TRUE)
> 
> ### PER EPOCH
> epochs = seq(1, K, by=n)
> em_ep <- em[1:(K/n),]
> em_ep$iteration <- 1:(K/n)
> iem_ep <- iem[epochs,]
> iem_ep$iteration <- 1:(K/n)
> oem_ep <- oem[epochs,]
> oem_ep$iteration <- 1:(K/n)
> oemvr_ep <- oemvr[epochs,]
> oemvr_ep$iteration <- 1:(K/n)
> 
> # variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
> #                   oem_ep[2:20,c(1,5,8)],em_scaled_ep[2:20,c(1,5,8)])
> 
> variance <- rbind(oemvr_ep[,c(1,5,8)],iem_ep[,c(1,5,8)],
+                   oem_ep[,c(1,5,8)],em_ep[,c(1,5,8)])
> variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
+                   oem_ep[2:20,c(1,5,8)],em_ep[2:20,c(1,5,8)])
> variance <- rbind(oemvr_ep[5:20,c(1,5,8)],iem_ep[5:20,c(1,5,8)],
+                   oem_ep[5:20,c(1,5,8)],em_ep[5:20,c(1,5,8)])
> # variance <- rbind(iem_ep[10:20,c(1,5,8)],em_ep[10:20,c(1,5,8)])
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> 
> print('EM')
[1] "EM"
> dem <- NULL
> 
> df.em <- vector("list", length=nsim)
> Kem <- K/n
> 
> nbr<-1
> diem <- NULL
> df.iem <- vector("list", length=nsim)
> 
> doem <- NULL
> df.oem <- vector("list", length=nsim)
> 
> doemvr <- NULL
> df.oemvr <- vector("list", length=nsim)
> 
> rho.oemvr <- 0.9
> kiter = 1:K
> rho.oem = 3/(kiter+10)
> 
> for (j in (1:nsim))
+ {
+   print(j)
+   seed <- j*seed0
+   set.seed(seed)
+   x <- matrix(0,nrow=n,ncol=nsim)
+   xj<-mixt.simulate(n,weight,mu,sigma)
+   x[,j] <- xj
+ 
+   df <- mixt.em(x[,j], theta0, Kem)
+   # ML <- df
+   # ML[1:(K+1),2:7]<- df[(K+1),2:7]
+   df[,2:7] <- (df[,2:7] - ML[1:(Kem+1),2:7])^2
+   df$rep <- j
+   dem <- rbind(dem,df)
+   df$rep <- NULL
+   df.em[[j]] <- df
+ 
+   df <- mixt.iem(x[,j], theta0, K,nbr)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   diem <- rbind(diem,df)
+   df$rep <- NULL
+   df.iem[[j]] <- df
+ 
+   df <- mixt.oem(x[,j], theta0, K,nbr,rho.oem)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   doem <- rbind(doem,df)
+   df$rep <- NULL
+   df.oem[[j]] <- df
+ 
+   df <- mixt.oemvr(x[,j], theta0, K,nbr,rho.oemvr)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   doemvr <- rbind(doemvr,df)
+   df$rep <- NULL
+   df.oemvr[[j]] <- df
+ }
[1] 1
[1] 2
[1] 3
> 
> 
> 
> # dem[,2:7] <- dem[,2:7]^2
> em <- NULL
> em <- dem[dem$rep==1,]
> 
> if (nsim>2) {
+    for (j in (2:nsim))
+ {
+   em[,2:7] <- em[,2:7]+dem[dem$rep==j,2:7]
+ }
+ }
> em[,2:7] <- 1/nsim*em[,2:7]
> em[,9]<-NULL
> 
> 
> 
> iem <- NULL
> iem <- diem[diem$rep==1,]
> 
> if (nsim>2) {
+ for (j in (2:nsim))
+ {
+   iem[,2:7] <- iem[,2:7]+diem[diem$rep==j,2:7]
+ }
+ }
> 
> iem[,2:7] <- 1/nsim*iem[,2:7]
> iem[,9]<-NULL
> 
> 
> 
> oem <- NULL
> oem <- doem[doem$rep==1,]
> 
> if (nsim>2) {
+     for (j in (2:nsim))
+   {
+     oem[,2:7] <- oem[,2:7]+doem[doem$rep==j,2:7]
+   }
+ }
> 
> oem[,2:7] <- 1/nsim*oem[,2:7]
> oem[,9]<-NULL
> 
> 
> 
> 
> # doemvr <- NULL
> # df.oemvr <- vector("list", length=nsim)
> # rho <- 0.001
> # for (j in (1:nsim))
> # {
> #   print(j)
> #   df <- mixt.oemvr(x[,j], theta0, K,nbr, rho)
> #   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
> #   df$rep <- j
> #   doemvr <- rbind(doemvr,df)
> #   df$rep <- NULL
> #   df.oemvr[[j]] <- df
> # }
> 
> 
> oemvr <- NULL
> oemvr <- doemvr[doemvr$rep==1,]
> 
> if (nsim>2) {
+     for (j in (2:nsim))
+   {
+     oemvr[,2:7] <- oemvr[,2:7]+doemvr[doemvr$rep==j,2:7]
+   }
+ }
> 
> oemvr[,2:7] <- 1/nsim*oemvr[,2:7]
> oemvr[,9]<-NULL
> 
> # oemvr$algo <- 'OEMvr'
> # oemvr$rep <- NULL
> # variance <- NULL
> # variance <- rbind(oemvr[1:(K+1),c(1,5,8)],iem[1:(K+1),c(1,5,8)],oem[1:(K+<[1:(K+1),c(1,5,8)],iem[1:(K+1),c(1,5,8)],oem[1:(K+1                        ),c(1,5,8)],em_scaled[1:(<K+1),c(1,5,8)],oem[1:(K+1),c(1,5,8)],em_scaled[1:(K                        +1),c(1,5,8)])
> # graphConvMC2_new(variance, title="IEMs",legend=TRUE)
> 
> 
> iem$algo <- 'IEM'
> oem$algo <- 'OEM'
> oemvr$algo <- 'OEMvr'
> em$algo <- 'EM'
> 
> em$rep <- NULL
> iem$rep <- NULL
> oem$rep <- NULL
> oemvr$rep <- NULL
> 
> 
> # variance <- NULL
> # # variance <- rbind(oemvr[1001:2001,c(1,5,8)],iem[1001:2001,c(1,5,8)],oem<vr[1001:2001,c(1,5,8)],iem[1001:2001,c(1,5,8)],oem[                        1001:2001,c(1,5,8)],em_sc<[1001:2001,c(1,5,8)],oem[1001:2001,c(1,5,8)],em_sca                        led[1001:2001,c(1,5,8)])
> # variance <- rbind(oemvr[2:(K+1),c(1,5,8)],iem[2:(K+1),c(1,5,8)],oem[2:(K+<[2:(K+1),c(1,5,8)],iem[2:(K+1),c(1,5,8)],oem[2:(K+1                        ),c(1,5,8)],em_scaled[2:(<K+1),c(1,5,8)],oem[2:(K+1),c(1,5,8)],em_scaled[2:(K                        +1),c(1,5,8)])
> # graphConvMC2_new(variance, title="IEMs",legend=TRUE)
> 
> ### PER EPOCH
> epochs = seq(1, K, by=n)
> em_ep <- em[1:(K/n),]
> em_ep$iteration <- 1:(K/n)
> iem_ep <- iem[epochs,]
> iem_ep$iteration <- 1:(K/n)
> oem_ep <- oem[epochs,]
> oem_ep$iteration <- 1:(K/n)
> oemvr_ep <- oemvr[epochs,]
> oemvr_ep$iteration <- 1:(K/n)
> 
> # variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
> #                   oem_ep[2:20,c(1,5,8)],em_scaled_ep[2:20,c(1,5,8)])
> 
> variance <- rbind(oemvr_ep[,c(1,5,8)],iem_ep[,c(1,5,8)],
+                   oem_ep[,c(1,5,8)],em_ep[,c(1,5,8)])
> variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
+                   oem_ep[2:20,c(1,5,8)],em_ep[2:20,c(1,5,8)])
> variance <- rbind(oemvr_ep[5:20,c(1,5,8)],iem_ep[5:20,c(1,5,8)],
+                   oem_ep[5:20,c(1,5,8)],em_ep[5:20,c(1,5,8)])
> # variance <- rbind(iem_ep[10:20,c(1,5,8)],em_ep[10:20,c(1,5,8)])
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> print('EM')
[1] "EM"
> dem <- NULL
> 
> df.em <- vector("list", length=nsim)
> Kem <- K/n
> 
> nbr<-1
> diem <- NULL
> df.iem <- vector("list", length=nsim)
> 
> doem <- NULL
> df.oem <- vector("list", length=nsim)
> 
> doemvr <- NULL
> df.oemvr <- vector("list", length=nsim)
> 
> rho.oemvr <- 0.5
> kiter = 1:K
> rho.oem = 1/(kiter+10)
> 
> for (j in (1:nsim))
+ {
+   print(j)
+   seed <- j*seed0
+   set.seed(seed)
+   x <- matrix(0,nrow=n,ncol=nsim)
+   xj<-mixt.simulate(n,weight,mu,sigma)
+   x[,j] <- xj
+ 
+   df <- mixt.em(x[,j], theta0, Kem)
+   # ML <- df
+   # ML[1:(K+1),2:7]<- df[(K+1),2:7]
+   df[,2:7] <- (df[,2:7] - ML[1:(Kem+1),2:7])^2
+   df$rep <- j
+   dem <- rbind(dem,df)
+   df$rep <- NULL
+   df.em[[j]] <- df
+ 
+   df <- mixt.iem(x[,j], theta0, K,nbr)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   diem <- rbind(diem,df)
+   df$rep <- NULL
+   df.iem[[j]] <- df
+ 
+   df <- mixt.oem(x[,j], theta0, K,nbr,rho.oem)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   doem <- rbind(doem,df)
+   df$rep <- NULL
+   df.oem[[j]] <- df
+ 
+   df <- mixt.oemvr(x[,j], theta0, K,nbr,rho.oemvr)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   doemvr <- rbind(doemvr,df)
+   df$rep <- NULL
+   df.oemvr[[j]] <- df
+ }
[1] 1
[1] 2
[1] 3
> 
> 
> 
> # dem[,2:7] <- dem[,2:7]^2
> em <- NULL
> em <- dem[dem$rep==1,]
> 
> if (nsim>2) {
+    for (j in (2:nsim))
+ {
+   em[,2:7] <- em[,2:7]+dem[dem$rep==j,2:7]
+ }
+ }
> em[,2:7] <- 1/nsim*em[,2:7]
> em[,9]<-NULL
> 
> 
> 
> iem <- NULL
> iem <- diem[diem$rep==1,]
> 
> if (nsim>2) {
+ for (j in (2:nsim))
+ {
+   iem[,2:7] <- iem[,2:7]+diem[diem$rep==j,2:7]
+ }
+ }
> 
> iem[,2:7] <- 1/nsim*iem[,2:7]
> iem[,9]<-NULL
> 
> 
> 
> oem <- NULL
> oem <- doem[doem$rep==1,]
> 
> if (nsim>2) {
+     for (j in (2:nsim))
+   {
+     oem[,2:7] <- oem[,2:7]+doem[doem$rep==j,2:7]
+   }
+ }
> 
> oem[,2:7] <- 1/nsim*oem[,2:7]
> oem[,9]<-NULL
> 
> 
> 
> 
> # doemvr <- NULL
> # df.oemvr <- vector("list", length=nsim)
> # rho <- 0.001
> # for (j in (1:nsim))
> # {
> #   print(j)
> #   df <- mixt.oemvr(x[,j], theta0, K,nbr, rho)
> #   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
> #   df$rep <- j
> #   doemvr <- rbind(doemvr,df)
> #   df$rep <- NULL
> #   df.oemvr[[j]] <- df
> # }
> 
> 
> oemvr <- NULL
> oemvr <- doemvr[doemvr$rep==1,]
> 
> if (nsim>2) {
+     for (j in (2:nsim))
+   {
+     oemvr[,2:7] <- oemvr[,2:7]+doemvr[doemvr$rep==j,2:7]
+   }
+ }
> 
> oemvr[,2:7] <- 1/nsim*oemvr[,2:7]
> oemvr[,9]<-NULL
> 
> # oemvr$algo <- 'OEMvr'
> # oemvr$rep <- NULL
> # variance <- NULL
> # variance <- rbind(oemvr[1:(K+1),c(1,5,8)],iem[1:(K+1),c(1,5,8)],oem[1:(K+<[1:(K+1),c(1,5,8)],iem[1:(K+1),c(1,5,8)],oem[1:(K+1                        ),c(1,5,8)],em_scaled[1:(<K+1),c(1,5,8)],oem[1:(K+1),c(1,5,8)],em_scaled[1:(K                        +1),c(1,5,8)])
> # graphConvMC2_new(variance, title="IEMs",legend=TRUE)
> 
> 
> iem$algo <- 'IEM'
> oem$algo <- 'OEM'
> oemvr$algo <- 'OEMvr'
> em$algo <- 'EM'
> 
> em$rep <- NULL
> iem$rep <- NULL
> oem$rep <- NULL
> oemvr$rep <- NULL
> 
> 
> # variance <- NULL
> # # variance <- rbind(oemvr[1001:2001,c(1,5,8)],iem[1001:2001,c(1,5,8)],oem<vr[1001:2001,c(1,5,8)],iem[1001:2001,c(1,5,8)],oem[                        1001:2001,c(1,5,8)],em_sc<[1001:2001,c(1,5,8)],oem[1001:2001,c(1,5,8)],em_sca                        led[1001:2001,c(1,5,8)])
> # variance <- rbind(oemvr[2:(K+1),c(1,5,8)],iem[2:(K+1),c(1,5,8)],oem[2:(K+<[2:(K+1),c(1,5,8)],iem[2:(K+1),c(1,5,8)],oem[2:(K+1                        ),c(1,5,8)],em_scaled[2:(<K+1),c(1,5,8)],oem[2:(K+1),c(1,5,8)],em_scaled[2:(K                        +1),c(1,5,8)])
> # graphConvMC2_new(variance, title="IEMs",legend=TRUE)
> 
> ### PER EPOCH
> epochs = seq(1, K, by=n)
> em_ep <- em[1:(K/n),]
> em_ep$iteration <- 1:(K/n)
> iem_ep <- iem[epochs,]
> iem_ep$iteration <- 1:(K/n)
> oem_ep <- oem[epochs,]
> oem_ep$iteration <- 1:(K/n)
> oemvr_ep <- oemvr[epochs,]
> oemvr_ep$iteration <- 1:(K/n)
> 
> # variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
> #                   oem_ep[2:20,c(1,5,8)],em_scaled_ep[2:20,c(1,5,8)])
> 
> variance <- rbind(oemvr_ep[,c(1,5,8)],iem_ep[,c(1,5,8)],
+                   oem_ep[,c(1,5,8)],em_ep[,c(1,5,8)])
> variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
+                   oem_ep[2:20,c(1,5,8)],em_ep[2:20,c(1,5,8)])
> variance <- rbind(oemvr_ep[5:20,c(1,5,8)],iem_ep[5:20,c(1,5,8)],
+                   oem_ep[5:20,c(1,5,8)],em_ep[5:20,c(1,5,8)])
> # variance <- rbind(iem_ep[10:20,c(1,5,8)],em_ep[10:20,c(1,5,8)])
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> 
> print('EM')
[1] "EM"
> dem <- NULL
> 
> df.em <- vector("list", length=nsim)
> Kem <- K/n
> 
> nbr<-1
> diem <- NULL
> df.iem <- vector("list", length=nsim)
> 
> doem <- NULL
> df.oem <- vector("list", length=nsim)
> 
> doemvr <- NULL
> df.oemvr <- vector("list", length=nsim)
> 
> rho.oemvr <- 0.5
> kiter = 1:K
> rho.oem = 2/(kiter+10)
> 
> for (j in (1:nsim))
+ {
+   print(j)
+   seed <- j*seed0
+   set.seed(seed)
+   x <- matrix(0,nrow=n,ncol=nsim)
+   xj<-mixt.simulate(n,weight,mu,sigma)
+   x[,j] <- xj
+ 
+   df <- mixt.em(x[,j], theta0, Kem)
+   # ML <- df
+   # ML[1:(K+1),2:7]<- df[(K+1),2:7]
+   df[,2:7] <- (df[,2:7] - ML[1:(Kem+1),2:7])^2
+   df$rep <- j
+   dem <- rbind(dem,df)
+   df$rep <- NULL
+   df.em[[j]] <- df
+ 
+   df <- mixt.iem(x[,j], theta0, K,nbr)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   diem <- rbind(diem,df)
+   df$rep <- NULL
+   df.iem[[j]] <- df
+ 
+   df <- mixt.oem(x[,j], theta0, K,nbr,rho.oem)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   doem <- rbind(doem,df)
+   df$rep <- NULL
+   df.oem[[j]] <- df
+ 
+   df <- mixt.oemvr(x[,j], theta0, K,nbr,rho.oemvr)
+   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
+   df$rep <- j
+   doemvr <- rbind(doemvr,df)
+   df$rep <- NULL
+   df.oemvr[[j]] <- df
+ }
[1] 1
[1] 2
[1] 3
> 
> 
> 
> # dem[,2:7] <- dem[,2:7]^2
> em <- NULL
> em <- dem[dem$rep==1,]
> 
> if (nsim>2) {
+    for (j in (2:nsim))
+ {
+   em[,2:7] <- em[,2:7]+dem[dem$rep==j,2:7]
+ }
+ }
> em[,2:7] <- 1/nsim*em[,2:7]
> em[,9]<-NULL
> 
> 
> 
> iem <- NULL
> iem <- diem[diem$rep==1,]
> 
> if (nsim>2) {
+ for (j in (2:nsim))
+ {
+   iem[,2:7] <- iem[,2:7]+diem[diem$rep==j,2:7]
+ }
+ }
> 
> iem[,2:7] <- 1/nsim*iem[,2:7]
> iem[,9]<-NULL
> 
> 
> 
> oem <- NULL
> oem <- doem[doem$rep==1,]
> 
> if (nsim>2) {
+     for (j in (2:nsim))
+   {
+     oem[,2:7] <- oem[,2:7]+doem[doem$rep==j,2:7]
+   }
+ }
> 
> oem[,2:7] <- 1/nsim*oem[,2:7]
> oem[,9]<-NULL
> 
> 
> 
> 
> # doemvr <- NULL
> # df.oemvr <- vector("list", length=nsim)
> # rho <- 0.001
> # for (j in (1:nsim))
> # {
> #   print(j)
> #   df <- mixt.oemvr(x[,j], theta0, K,nbr, rho)
> #   df[,2:7] <- (df[,2:7] - ML[,2:7])^2
> #   df$rep <- j
> #   doemvr <- rbind(doemvr,df)
> #   df$rep <- NULL
> #   df.oemvr[[j]] <- df
> # }
> 
> 
> oemvr <- NULL
> oemvr <- doemvr[doemvr$rep==1,]
> 
> if (nsim>2) {
+     for (j in (2:nsim))
+   {
+     oemvr[,2:7] <- oemvr[,2:7]+doemvr[doemvr$rep==j,2:7]
+   }
+ }
> 
> oemvr[,2:7] <- 1/nsim*oemvr[,2:7]
> oemvr[,9]<-NULL
> 
> # oemvr$algo <- 'OEMvr'
> # oemvr$rep <- NULL
> # variance <- NULL
> # variance <- rbind(oemvr[1:(K+1),c(1,5,8)],iem[1:(K+1),c(1,5,8)],oem[1:(K+<[1:(K+1),c(1,5,8)],iem[1:(K+1),c(1,5,8)],oem[1:(K+1                        ),c(1,5,8)],em_scaled[1:(<K+1),c(1,5,8)],oem[1:(K+1),c(1,5,8)],em_scaled[1:(K                        +1),c(1,5,8)])
> # graphConvMC2_new(variance, title="IEMs",legend=TRUE)
> 
> 
> iem$algo <- 'IEM'
> oem$algo <- 'OEM'
> oemvr$algo <- 'OEMvr'
> em$algo <- 'EM'
> 
> em$rep <- NULL
> iem$rep <- NULL
> oem$rep <- NULL
> oemvr$rep <- NULL
> 
> 
> # variance <- NULL
> # # variance <- rbind(oemvr[1001:2001,c(1,5,8)],iem[1001:2001,c(1,5,8)],oem<vr[1001:2001,c(1,5,8)],iem[1001:2001,c(1,5,8)],oem[                        1001:2001,c(1,5,8)],em_sc<[1001:2001,c(1,5,8)],oem[1001:2001,c(1,5,8)],em_sca                        led[1001:2001,c(1,5,8)])
> # variance <- rbind(oemvr[2:(K+1),c(1,5,8)],iem[2:(K+1),c(1,5,8)],oem[2:(K+<[2:(K+1),c(1,5,8)],iem[2:(K+1),c(1,5,8)],oem[2:(K+1                        ),c(1,5,8)],em_scaled[2:(<K+1),c(1,5,8)],oem[2:(K+1),c(1,5,8)],em_scaled[2:(K                        +1),c(1,5,8)])
> # graphConvMC2_new(variance, title="IEMs",legend=TRUE)
> 
> ### PER EPOCH
> epochs = seq(1, K, by=n)
> em_ep <- em[1:(K/n),]
> em_ep$iteration <- 1:(K/n)
> iem_ep <- iem[epochs,]
> iem_ep$iteration <- 1:(K/n)
> oem_ep <- oem[epochs,]
> oem_ep$iteration <- 1:(K/n)
> oemvr_ep <- oemvr[epochs,]
> oemvr_ep$iteration <- 1:(K/n)
> 
> # variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
> #                   oem_ep[2:20,c(1,5,8)],em_scaled_ep[2:20,c(1,5,8)])
> 
> variance <- rbind(oemvr_ep[,c(1,5,8)],iem_ep[,c(1,5,8)],
+                   oem_ep[,c(1,5,8)],em_ep[,c(1,5,8)])
> variance <- rbind(oemvr_ep[2:20,c(1,5,8)],iem_ep[2:20,c(1,5,8)],
+                   oem_ep[2:20,c(1,5,8)],em_ep[2:20,c(1,5,8)])
> variance <- rbind(oemvr_ep[5:20,c(1,5,8)],iem_ep[5:20,c(1,5,8)],
+                   oem_ep[5:20,c(1,5,8)],em_ep[5:20,c(1,5,8)])
> # variance <- rbind(iem_ep[10:20,c(1,5,8)],em_ep[10:20,c(1,5,8)])
> graphConvMC2_new(variance, title="IEMs",legend=TRUE)
Warning: Ignoring unknown aesthetics: by
> save.image("gmm_mu_fixed.RData")
> require(ggplot2)
> require(gridExtra)
> require(reshape2)
> 
> mixt.simulate <-function(n,weight,mu,sigma)
+ {
+   G <- length(mu)
+   Z <- sample(1:G, n, prob=weight, replace=T)
+   x<-NULL
+   for (g in 1:G)
+   {
+     x<-c(x,rnorm(length(which(Z==g)),mu[g],sigma[g]))
+   }
+   return(x)
+ }
> 
> 
> 
> #-------------------------------------
> 
> mixt.em <- function(x, theta0, K)
+ {
+   G<-length(mu)
+   col.names <- c("iteration", paste0("p",1:G), paste0("mu",1:G), paste0("si<on", paste0("p",1:G), paste0("mu",1:G), paste0("sig                        ma",1:G))
+   
+   theta.est <- matrix(NA,K+1,3*G+1)
+   theta.est[1,] <- c(0, theta0$p, theta0$mu, theta0$sigma)
+   
+   theta<-theta0
+   for (k in 1:K)
+   {
+     s<-step.E(x,theta)
+     theta<-step.M(s,n)
+     theta.est[k+1,] <- c(k, theta$p, theta$mu, theta$sigma)
+   }
+   
+   df <- as.data.frame(theta.est)
+   names(df) <- col.names
+   return(df)
+ }
> 
> mixt.iem <- function(x, theta0, K,nbr)
+ {
+   G<-length(mu)
+   col.names <- c("iteration", paste0("p",1:G), paste0("mu",1:G), paste0("si<on", paste0("p",1:G), paste0("mu",1:G), paste0("sig                        ma",1:G))
+   
+   theta.est <- matrix(NA,K+1,3*G+1)
+   theta.est[1,] <- c(0, theta0$p, theta0$mu, theta0$sigma)
+   tau <- compute.tau(x,theta0)
+   theta<-theta0
+   tau.old <- compute.tau(x[1],theta0)
+   s <- compute.stat_iem(x,tau, tau.old,1)
+ 
+   l <- rep(sample(1:n,n), K/n)
+   i <- 1:nbr
+   for (k in 1:K)
+   {
+ 
+     if (k%%(n/nbr) == 1)
+     { 
+       # l<-sample(1:n,n)
+       # l<-1:n
+       i<-1:nbr
+     }
+     # tau.new <- compute.tau(x[i],theta)
+     # s <- compute.stat_iem(x,tau, tau.new, i)
+     tau[l[i],] <- compute.tau(x[l[i]],theta)
+     s <- compute.stat(x,tau)
+     theta<-step.M(s,n)
+     theta.est[k+1,] <- c(k, theta$p, theta$mu, theta$sigma)
+     i = i+nbr
+   }
+   
+   df <- as.data.frame(theta.est)
+   names(df) <- col.names
+   return(df)
+ }
> 
> 
> # mixt.oem <- function(x, theta0, K,nbr)
> # {
> #   G<-length(mu)
> #   kiter = 1:K
> #   rho = 1/(kiter+1)
> #   col.names <- c("iteration", paste0("p",1:G), paste0("mu",1:G), paste0("<tion", paste0("p",1:G), paste0("mu",1:G), paste0("s                        igma",1:G))
>   
> #   theta.est <- matrix(NA,K+1,3*G+1)
> #   theta.est[1,] <- c(0, theta0$p, theta0$mu, theta0$sigma)
> #   theta<-theta0
>   
> #   tau<-compute.tau(x,theta)
> #   s<-compute.stat(x,tau)
> #   s.old <- s
> #   theta<-step.M(s,n)
> #   n<-length(x)
> #   l <- NULL
> #   l <- rep(sample(1:n,n), K/n)
> #   i <- 1:nbr
> #   for (k in 1:K)
> #   {
> #     if (k%%(n/nbr) == 1)
> #     { 
> #       i<-1:nbr
> #     }
> #     tau.new <- compute.tau(x[l[i]],theta)
> #     s <- compute.stat_oem(x,tau,s.old, tau.new, l[i],rho[k])
> #     s.old <- s
> #     i <- i+nbr
> #     theta<-step.M(s,n)
> #     theta.est[k+1,] <- c(k, theta$p, theta$mu, theta$sigma)
> #   }
>   
> #   df <- as.data.frame(theta.est)
> #   names(df) <- col.names
> #   return(df)
> # }
> 
> # mixt.oemvr <- function(x, theta0, K,nbr,rho)
> # {
> #    G<-length(mu)
> #   col.names <- c("iteration", paste0("p",1:G), paste0("mu",1:G), paste0("<tion", paste0("p",1:G), paste0("mu",1:G), paste0("s                        igma",1:G))
> #   rho = 0.0001
> #   theta.est <- matrix(NA,K+1,3*G+1)
> #   theta.est[1,] <- c(0, theta0$p, theta0$mu, theta0$sigma)
> #   tau <- compute.tau(x,theta0)
> #   tau.old.init <- tau[1,]
> #   theta<-theta0
> #   s<-compute.stat(x,tau)
> #   s.old <- s
> #   s.old.init <- s
> #   l <- rep(sample(1:n,n), K/n)
> #   i <- 1:nbr
> #   for (k in 1:K)
> #   {
> #     if (k%%(n/nbr) == 1)
> #     { 
> #       i<-1:nbr
> #       tau.old.init <- compute.tau(x[i],theta)
> #       s.old.init <- compute.stat(x,tau)
> #     }
> #     tau.new <- compute.tau(x[i],theta)
> #     s <- compute.stat_oemvr(x,tau, tau.new,s.old,s.old.init,tau.old.init,<emvr(x,tau, tau.new,s.old,s.old.init,tau.old.init,                         i,rho)
> #     s.old <- s
> #     i <- i+nbr
> #     theta<-step.M(s,n)
> #     theta.est[k+1,] <- c(k, theta$p, theta$mu, theta$sigma)
> #   }
>   
> #   df <- as.data.frame(theta.est)
> #   names(df) <- col.names
> #   return(df)
> # }
> 
> 
> 
> mixt.oem <- function(x, theta0, K,nbr,rho)
+ {
+    G<-length(mu)
+   col.names <- c("iteration", paste0("p",1:G), paste0("mu",1:G), paste0("si<on", paste0("p",1:G), paste0("mu",1:G), paste0("sig                        ma",1:G))
+   theta.est <- matrix(NA,K+1,3*G+1)
+   theta.est[1,] <- c(0, theta0$p, theta0$mu, theta0$sigma)
+   theta<-theta0
+ 
+   #Init
+   tau <- compute.tau(x,theta)
+   s<-compute.stat(x,tau)
+   
+   l <- NULL
+   l <- rep(sample(1:n,n), K/n)
+   i <- 1:nbr
+   
+   for (k in 1:K)
+   {
+     if (k%%(n/nbr) == 1)
+     { 
+       i<-1:nbr
+     }
+ 
+     tau.indiv.new <- compute.tau(x[l[i]],theta)
+     s.indiv.new <- x[l[i]]*tau.indiv.new
+ 
+     #Update statistic
+     s$s1 <- s$s1 + rho[k]*(tau.indiv.new  - s$s1)
+     s$s2 <- s$s2 + rho[k]*(s.indiv.new  - s$s2)
+     s$s3 <- s$s3 + rho[k]*(x[l[i]]^2*tau.indiv.new  - s$s3)
+     theta <- step.M(s,n)
+     theta.est[k+1,] <- c(k, theta$p, theta$mu, theta$sigma)
+ 
+     #Update index
+     i <- i+nbr
+ 
+   }
+   
+   df <- as.data.frame(theta.est)
+   names(df) <- col.names
+   return(df)
+ }
> 
> mixt.oemvr <- function(x, theta0, K,nbr,rho)
+ {
+    G<-length(mu)
+   col.names <- c("iteration", paste0("p",1:G), paste0("mu",1:G), paste0("si<on", paste0("p",1:G), paste0("mu",1:G), paste0("sig                        ma",1:G))
+   theta.est <- matrix(NA,K+1,3*G+1)
+   theta.est[1,] <- c(0, theta0$p, theta0$mu, theta0$sigma)
+   theta<-theta0
+   
+   #Init
+   tau <- compute.tau(x,theta)
+   s<-compute.stat(x,tau)
+   
+   l <- NULL
+   l <- rep(sample(1:n,n), K/n)
+   i <- 1:nbr
+   
+   for (k in 1:K)
+   {
+     if (k%%(n/nbr) == 1)
+     { 
+       i<-1:nbr
+       theta.e.0 <- theta
+     }
+ 
+     tau.indiv.new <- compute.tau(x[l[i]],theta)
+     s.indiv.new <- x[l[i]]*tau.indiv.new
+ 
+     tau.indiv.e.0 <- compute.tau(x[l[i]],theta.e.0)
+     s.indiv.e.0 <- x[l[i]]*tau.indiv.e.0
+ 
+     tau.e.0 <- compute.tau(x,theta.e.0)
+     s.e.0 <- x%*%tau.e.0
+ 
+     #Update statistic
+     s$s1 <- s$s1 + rho*(tau.indiv.new - tau.indiv.e.0 + colSums(tau.e.0) - <au.indiv.new - tau.indiv.e.0 + colSums(tau.e.0) - s                        $s1)
+     s$s2 <- s$s2 + rho*(s.indiv.new - s.indiv.e.0 + s.e.0 - s$s2)
+     s$s3 <- s$s3 + rho*(x[l[i]]*s.indiv.new - x[l[i]]*s.indiv.e.0 + (x^2)%*<[l[i]]*s.indiv.new - x[l[i]]*s.indiv.e.0 + (x^2)%*%                        tau.e.0 - s$s3)
+ 
+     theta <- step.M(s,n)
+     theta.est[k+1,] <- c(k, theta$p, theta$mu, theta$sigma)
+ 
+     #Update index
+     i <- i+nbr
+ 
+   }
+   
+   df <- as.data.frame(theta.est)
+   names(df) <- col.names
+   return(df)
+ }
> 
> 
> 
> 
> 